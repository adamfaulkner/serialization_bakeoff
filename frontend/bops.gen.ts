//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.1.3
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord, BebopJson, BebopTypeGuard, Guid, GuidMap } from "bebop";

export const BEBOP_SCHEMA = new Uint8Array ([
3, 4, 0, 0, 0, 82, 105, 100, 101, 97, 98, 108, 101, 84,
121, 112, 101, 0, 4, 0, 251, 255, 255, 255, 0, 4, 0, 0, 0,
3, 85, 78, 75, 78, 79, 87, 78, 0, 0, 0, 0, 0, 0, 66, 73,
67, 89, 67, 76, 69, 0, 0, 1, 0, 0, 0, 69, 66, 73, 67, 89,
67, 76, 69, 0, 0, 2, 0, 0, 0, 77, 101, 109, 98, 101, 114,
67, 97, 115, 117, 97, 108, 0, 4, 0, 251, 255, 255, 255, 0,
4, 0, 0, 0, 3, 85, 78, 75, 78, 79, 87, 78, 0, 0, 0, 0, 0,
0, 77, 69, 77, 66, 69, 82, 0, 0, 1, 0, 0, 0, 67, 65, 83,
85, 65, 76, 0, 0, 2, 0, 0, 0, 84, 114, 105, 112, 0, 2, 0,
5, 0, 0, 0, 13, 114, 105, 100, 101, 95, 105, 100, 0, 245,
255, 255, 255, 0, 1, 114, 105, 100, 101, 97, 98, 108, 101,
95, 116, 121, 112, 101, 0, 0, 0, 0, 0, 0, 2, 115, 116, 97,
114, 116, 101, 100, 95, 97, 116, 0, 243, 255, 255, 255, 0,
3, 101, 110, 100, 101, 100, 95, 97, 116, 0, 243, 255, 255,
255, 0, 4, 115, 116, 97, 114, 116, 95, 115, 116, 97, 116,
105, 111, 110, 95, 110, 97, 109, 101, 0, 245, 255, 255,
255, 0, 5, 115, 116, 97, 114, 116, 95, 115, 116, 97, 116,
105, 111, 110, 95, 105, 100, 0, 245, 255, 255, 255, 0, 6,
101, 110, 100, 95, 115, 116, 97, 116, 105, 111, 110, 95,
110, 97, 109, 101, 0, 245, 255, 255, 255, 0, 7, 101, 110,
100, 95, 115, 116, 97, 116, 105, 111, 110, 95, 105, 100,
0, 245, 255, 255, 255, 0, 8, 115, 116, 97, 114, 116, 95,
108, 97, 116, 0, 246, 255, 255, 255, 0, 9, 115, 116, 97,
114, 116, 95, 108, 110, 103, 0, 246, 255, 255, 255, 0, 10,
101, 110, 100, 95, 108, 97, 116, 0, 246, 255, 255, 255, 0,
11, 101, 110, 100, 95, 108, 110, 103, 0, 246, 255, 255,
255, 0, 12, 109, 101, 109, 98, 101, 114, 95, 99, 97, 115,
117, 97, 108, 0, 1, 0, 0, 0, 0, 13, 83, 101, 114, 118,
101, 114, 82, 101, 115, 112, 111, 110, 115, 101, 65, 108,
108, 0, 2, 0, 5, 0, 0, 0, 1, 116, 114, 105, 112, 115, 0,
242, 255, 255, 255, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0
]);

export enum RideableType {

  Unknown = 0,

  Bicycle = 1,

  Ebicycle = 2,
}


export enum MemberCasual {

  Unknown = 0,

  Member = 1,

  Casual = 2,
}


export interface ITrip extends BebopRecord {

  rideId?: string;

  rideableType?: RideableType;

  startedAt?: Date;

  endedAt?: Date;

  startStationName?: string;

  startStationId?: string;

  endStationName?: string;

  endStationId?: string;

  startLat?: number;

  startLng?: number;

  endLat?: number;

  endLng?: number;

  memberCasual?: MemberCasual;
}

export class Trip implements ITrip {
  public rideId?: string;
  public rideableType?: RideableType;
  public startedAt?: Date;
  public endedAt?: Date;
  public startStationName?: string;
  public startStationId?: string;
  public endStationName?: string;
  public endStationId?: string;
  public startLat?: number;
  public startLng?: number;
  public endLat?: number;
  public endLng?: number;
  public memberCasual?: MemberCasual;

  constructor(record: ITrip) {
    this.rideId = record.rideId;
    this.rideableType = record.rideableType;
    this.startedAt = record.startedAt;
    this.endedAt = record.endedAt;
    this.startStationName = record.startStationName;
    this.startStationId = record.startStationId;
    this.endStationName = record.endStationName;
    this.endStationId = record.endStationId;
    this.startLat = record.startLat;
    this.startLng = record.startLng;
    this.endLat = record.endLat;
    this.endLng = record.endLng;
    this.memberCasual = record.memberCasual;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return Trip.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ITrip): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Trip.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Trip}.
   */
  public static validateCompatibility(record: ITrip): void {
    if (record.rideId !== undefined) {
      BebopTypeGuard.ensureString(record.rideId)
    }
    if (record.rideableType !== undefined) {
      BebopTypeGuard.ensureEnum(record.rideableType, RideableType);
    }
    if (record.startedAt !== undefined) {
      BebopTypeGuard.ensureDate(record.startedAt)
    }
    if (record.endedAt !== undefined) {
      BebopTypeGuard.ensureDate(record.endedAt)
    }
    if (record.startStationName !== undefined) {
      BebopTypeGuard.ensureString(record.startStationName)
    }
    if (record.startStationId !== undefined) {
      BebopTypeGuard.ensureString(record.startStationId)
    }
    if (record.endStationName !== undefined) {
      BebopTypeGuard.ensureString(record.endStationName)
    }
    if (record.endStationId !== undefined) {
      BebopTypeGuard.ensureString(record.endStationId)
    }
    if (record.startLat !== undefined) {
      BebopTypeGuard.ensureFloat(record.startLat)
    }
    if (record.startLng !== undefined) {
      BebopTypeGuard.ensureFloat(record.startLng)
    }
    if (record.endLat !== undefined) {
      BebopTypeGuard.ensureFloat(record.endLat)
    }
    if (record.endLng !== undefined) {
      BebopTypeGuard.ensureFloat(record.endLng)
    }
    if (record.memberCasual !== undefined) {
      BebopTypeGuard.ensureEnum(record.memberCasual, MemberCasual);
    }
  }

  /**
   * Unsafely creates an instance of {@link Trip} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ITrip {
      return new Trip(record);
  }

  /**
   * Creates a new {@link Trip} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ITrip {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Trip.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Trip.validateCompatibility(parsed);
    return Trip.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Trip.encode(this);
  }

  public static encode(record: ITrip): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Trip.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ITrip, view: BebopView): number {
    const before = view.length;
    const pos = view.reserveMessageLength();
    const start = view.length;
    if (record.rideId !== undefined) {
      view.writeByte(1);
      view.writeString(record.rideId);
    }
    if (record.rideableType !== undefined) {
      view.writeByte(2);
      view.writeUint32(record.rideableType);
    }
    if (record.startedAt !== undefined) {
      view.writeByte(3);
      view.writeDate(record.startedAt);
    }
    if (record.endedAt !== undefined) {
      view.writeByte(4);
      view.writeDate(record.endedAt);
    }
    if (record.startStationName !== undefined) {
      view.writeByte(5);
      view.writeString(record.startStationName);
    }
    if (record.startStationId !== undefined) {
      view.writeByte(6);
      view.writeString(record.startStationId);
    }
    if (record.endStationName !== undefined) {
      view.writeByte(7);
      view.writeString(record.endStationName);
    }
    if (record.endStationId !== undefined) {
      view.writeByte(8);
      view.writeString(record.endStationId);
    }
    if (record.startLat !== undefined) {
      view.writeByte(9);
      view.writeFloat64(record.startLat);
    }
    if (record.startLng !== undefined) {
      view.writeByte(10);
      view.writeFloat64(record.startLng);
    }
    if (record.endLat !== undefined) {
      view.writeByte(11);
      view.writeFloat64(record.endLat);
    }
    if (record.endLng !== undefined) {
      view.writeByte(12);
      view.writeFloat64(record.endLng);
    }
    if (record.memberCasual !== undefined) {
      view.writeByte(13);
      view.writeUint32(record.memberCasual);
    }
    view.writeByte(0);
    const end = view.length;
    view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ITrip {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Trip.readFrom(view);
  }

  public static readFrom(view: BebopView): ITrip {
    let message: ITrip = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return new Trip(message);

        case 1:
          message.rideId = view.readString();
          break;

        case 2:
          message.rideableType = view.readUint32() as RideableType;
          break;

        case 3:
          message.startedAt = view.readDate();
          break;

        case 4:
          message.endedAt = view.readDate();
          break;

        case 5:
          message.startStationName = view.readString();
          break;

        case 6:
          message.startStationId = view.readString();
          break;

        case 7:
          message.endStationName = view.readString();
          break;

        case 8:
          message.endStationId = view.readString();
          break;

        case 9:
          message.startLat = view.readFloat64();
          break;

        case 10:
          message.startLng = view.readFloat64();
          break;

        case 11:
          message.endLat = view.readFloat64();
          break;

        case 12:
          message.endLng = view.readFloat64();
          break;

        case 13:
          message.memberCasual = view.readUint32() as MemberCasual;
          break;

        default:
          view.index = end;
          return new Trip(message);
      }
    }
  }
}


export interface IServerResponseAll extends BebopRecord {

  trips?: Array<ITrip>;
}

export class ServerResponseAll implements IServerResponseAll {
  public trips?: Array<ITrip>;

  constructor(record: IServerResponseAll) {
    this.trips = record.trips;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return ServerResponseAll.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IServerResponseAll): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    ServerResponseAll.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link ServerResponseAll}.
   */
  public static validateCompatibility(record: IServerResponseAll): void {
    if (record.trips !== undefined) {
      BebopTypeGuard.ensureArray(record.trips, Trip.validateCompatibility);
    }
  }

  /**
   * Unsafely creates an instance of {@link ServerResponseAll} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IServerResponseAll {
      return new ServerResponseAll(record);
  }

  /**
   * Creates a new {@link ServerResponseAll} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IServerResponseAll {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`ServerResponseAll.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    ServerResponseAll.validateCompatibility(parsed);
    return ServerResponseAll.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return ServerResponseAll.encode(this);
  }

  public static encode(record: IServerResponseAll): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    ServerResponseAll.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IServerResponseAll, view: BebopView): number {
    const before = view.length;
    const pos = view.reserveMessageLength();
    const start = view.length;
    if (record.trips !== undefined) {
      view.writeByte(1);
      {
      const length0 = record.trips.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        Trip.encodeInto(record.trips[i0], view)
      }
    }
    }
    view.writeByte(0);
    const end = view.length;
    view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IServerResponseAll {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return ServerResponseAll.readFrom(view);
  }

  public static readFrom(view: BebopView): IServerResponseAll {
    let message: IServerResponseAll = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return new ServerResponseAll(message);

        case 1:
          {
        let length0 = view.readUint32();
        message.trips = new Array<ITrip>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: ITrip;
          x0 = Trip.readFrom(view);
          message.trips[i0] = x0;
        }
      }
          break;

        default:
          view.index = end;
          return new ServerResponseAll(message);
      }
    }
  }
}

