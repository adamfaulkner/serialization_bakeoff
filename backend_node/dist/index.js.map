{
  "version": 3,
  "sources": ["../node_modules/detect-libc/lib/process.js", "../node_modules/detect-libc/lib/filesystem.js", "../node_modules/detect-libc/lib/detect-libc.js", "../node_modules/msgpackr-extract/node_modules/node-gyp-build-optional-packages/node-gyp-build.js", "../node_modules/msgpackr-extract/node_modules/node-gyp-build-optional-packages/index.js", "../node_modules/msgpackr-extract/index.js", "../node_modules/node-gyp-build-optional-packages/index.js", "../node_modules/cbor-extract/index.js", "../src/index.ts", "../src/loadData.js", "../src/trip.js", "../node_modules/msgpackr/unpack.js", "../node_modules/msgpackr/pack.js", "../node_modules/msgpackr/struct.js", "../node_modules/msgpackr/node-index.js", "../node_modules/cbor-x/decode.js", "../node_modules/cbor-x/encode.js", "../node_modules/cbor-x/node-index.js", "../src/serializers.js"],
  "sourcesContent": ["// Copyright 2017 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst isLinux = () => process.platform === 'linux';\n\nlet report = null;\nconst getReport = () => {\n  if (!report) {\n    /* istanbul ignore next */\n    if (isLinux() && process.report) {\n      const orig = process.report.excludeNetwork;\n      process.report.excludeNetwork = true;\n      report = process.report.getReport();\n      process.report.excludeNetwork = orig;\n    } else {\n      report = {};\n    }\n  }\n  return report;\n};\n\nmodule.exports = { isLinux, getReport };\n", "// Copyright 2017 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst fs = require('fs');\n\n/**\n * The path where we can find the ldd\n */\nconst LDD_PATH = '/usr/bin/ldd';\n\n/**\n * Read the content of a file synchronous\n *\n * @param {string} path\n * @returns {string}\n */\nconst readFileSync = (path) => fs.readFileSync(path, 'utf-8');\n\n/**\n * Read the content of a file\n *\n * @param {string} path\n * @returns {Promise<string>}\n */\nconst readFile = (path) => new Promise((resolve, reject) => {\n  fs.readFile(path, 'utf-8', (err, data) => {\n    if (err) {\n      reject(err);\n    } else {\n      resolve(data);\n    }\n  });\n});\n\nmodule.exports = {\n  LDD_PATH,\n  readFileSync,\n  readFile\n};\n", "// Copyright 2017 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst childProcess = require('child_process');\nconst { isLinux, getReport } = require('./process');\nconst { LDD_PATH, readFile, readFileSync } = require('./filesystem');\n\nlet cachedFamilyFilesystem;\nlet cachedVersionFilesystem;\n\nconst command = 'getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true';\nlet commandOut = '';\n\nconst safeCommand = () => {\n  if (!commandOut) {\n    return new Promise((resolve) => {\n      childProcess.exec(command, (err, out) => {\n        commandOut = err ? ' ' : out;\n        resolve(commandOut);\n      });\n    });\n  }\n  return commandOut;\n};\n\nconst safeCommandSync = () => {\n  if (!commandOut) {\n    try {\n      commandOut = childProcess.execSync(command, { encoding: 'utf8' });\n    } catch (_err) {\n      commandOut = ' ';\n    }\n  }\n  return commandOut;\n};\n\n/**\n * A String constant containing the value `glibc`.\n * @type {string}\n * @public\n */\nconst GLIBC = 'glibc';\n\n/**\n * A Regexp constant to get the GLIBC Version.\n * @type {string}\n */\nconst RE_GLIBC_VERSION = /LIBC[a-z0-9 \\-).]*?(\\d+\\.\\d+)/i;\n\n/**\n * A String constant containing the value `musl`.\n * @type {string}\n * @public\n */\nconst MUSL = 'musl';\n\nconst isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-');\n\nconst familyFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return GLIBC;\n  }\n  if (Array.isArray(report.sharedObjects)) {\n    if (report.sharedObjects.some(isFileMusl)) {\n      return MUSL;\n    }\n  }\n  return null;\n};\n\nconst familyFromCommand = (out) => {\n  const [getconf, ldd1] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return GLIBC;\n  }\n  if (ldd1 && ldd1.includes(MUSL)) {\n    return MUSL;\n  }\n  return null;\n};\n\nconst getFamilyFromLddContent = (content) => {\n  if (content.includes('musl')) {\n    return MUSL;\n  }\n  if (content.includes('GNU C Library')) {\n    return GLIBC;\n  }\n  return null;\n};\n\nconst familyFromFilesystem = async () => {\n  if (cachedFamilyFilesystem !== undefined) {\n    return cachedFamilyFilesystem;\n  }\n  cachedFamilyFilesystem = null;\n  try {\n    const lddContent = await readFile(LDD_PATH);\n    cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);\n  } catch (e) {}\n  return cachedFamilyFilesystem;\n};\n\nconst familyFromFilesystemSync = () => {\n  if (cachedFamilyFilesystem !== undefined) {\n    return cachedFamilyFilesystem;\n  }\n  cachedFamilyFilesystem = null;\n  try {\n    const lddContent = readFileSync(LDD_PATH);\n    cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);\n  } catch (e) {}\n  return cachedFamilyFilesystem;\n};\n\n/**\n * Resolves with the libc family when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst family = async () => {\n  let family = null;\n  if (isLinux()) {\n    family = await familyFromFilesystem();\n    if (!family) {\n      family = familyFromReport();\n    }\n    if (!family) {\n      const out = await safeCommand();\n      family = familyFromCommand(out);\n    }\n  }\n  return family;\n};\n\n/**\n * Returns the libc family when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst familySync = () => {\n  let family = null;\n  if (isLinux()) {\n    family = familyFromFilesystemSync();\n    if (!family) {\n      family = familyFromReport();\n    }\n    if (!family) {\n      const out = safeCommandSync();\n      family = familyFromCommand(out);\n    }\n  }\n  return family;\n};\n\n/**\n * Resolves `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {Promise<boolean>}\n */\nconst isNonGlibcLinux = async () => isLinux() && await family() !== GLIBC;\n\n/**\n * Returns `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {boolean}\n */\nconst isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;\n\nconst versionFromFilesystem = async () => {\n  if (cachedVersionFilesystem !== undefined) {\n    return cachedVersionFilesystem;\n  }\n  cachedVersionFilesystem = null;\n  try {\n    const lddContent = await readFile(LDD_PATH);\n    const versionMatch = lddContent.match(RE_GLIBC_VERSION);\n    if (versionMatch) {\n      cachedVersionFilesystem = versionMatch[1];\n    }\n  } catch (e) {}\n  return cachedVersionFilesystem;\n};\n\nconst versionFromFilesystemSync = () => {\n  if (cachedVersionFilesystem !== undefined) {\n    return cachedVersionFilesystem;\n  }\n  cachedVersionFilesystem = null;\n  try {\n    const lddContent = readFileSync(LDD_PATH);\n    const versionMatch = lddContent.match(RE_GLIBC_VERSION);\n    if (versionMatch) {\n      cachedVersionFilesystem = versionMatch[1];\n    }\n  } catch (e) {}\n  return cachedVersionFilesystem;\n};\n\nconst versionFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return report.header.glibcVersionRuntime;\n  }\n  return null;\n};\n\nconst versionSuffix = (s) => s.trim().split(/\\s+/)[1];\n\nconst versionFromCommand = (out) => {\n  const [getconf, ldd1, ldd2] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return versionSuffix(getconf);\n  }\n  if (ldd1 && ldd2 && ldd1.includes(MUSL)) {\n    return versionSuffix(ldd2);\n  }\n  return null;\n};\n\n/**\n * Resolves with the libc version when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst version = async () => {\n  let version = null;\n  if (isLinux()) {\n    version = await versionFromFilesystem();\n    if (!version) {\n      version = versionFromReport();\n    }\n    if (!version) {\n      const out = await safeCommand();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\n\n/**\n * Returns the libc version when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst versionSync = () => {\n  let version = null;\n  if (isLinux()) {\n    version = versionFromFilesystemSync();\n    if (!version) {\n      version = versionFromReport();\n    }\n    if (!version) {\n      const out = safeCommandSync();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\n\nmodule.exports = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionSync\n};\n", "var fs = require('fs')\nvar path = require('path')\nvar url = require('url')\nvar os = require('os')\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\n\nvar vars = (process.config && process.config.variables) || {}\nvar prebuildsOnly = !!process.env.PREBUILDS_ONLY\nvar versions = process.versions\nvar abi = versions.modules\nif (versions.deno || process.isBun) {\n  // both Deno and Bun made the very poor decision to shoot themselves in the foot and lie about support for ABI\n  // (which they do not have)\n  abi = 'unsupported'\n}\nvar runtime = isElectron() ? 'electron' : (isNwjs() ? 'node-webkit' : 'node')\nvar arch = process.env.npm_config_arch || os.arch()\nvar platform = process.env.npm_config_platform || os.platform()\nvar libc = process.env.LIBC || (isMusl(platform) ? 'musl' : 'glibc')\n\nvar armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''\nvar uv = (versions.uv || '').split('.')[0]\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.resolve(dir))\n}\n\nload.resolve = load.path = function (dir) {\n  dir = path.resolve(dir || '.')\n  var packageName = ''\n  var packageNameError\n  try {\n    packageName = runtimeRequire(path.join(dir, 'package.json')).name;\n    var varName = packageName.toUpperCase().replace(/-/g, '_')\n    if (process.env[varName + '_PREBUILD']) dir = process.env[varName + '_PREBUILD']\n  } catch (err) {\n    packageNameError = err;\n  }\n  if (!prebuildsOnly) {\n    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n    if (release) return release\n\n    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n    if (debug) return debug\n  }\n\n  var prebuild = resolve(dir)\n  if (prebuild) return prebuild\n\n  var nearby = resolve(path.dirname(process.execPath))\n  if (nearby) return nearby\n\n  var platformPackage = (packageName[0] == '@' ? '' : '@' + packageName + '/') + packageName + '-' + platform + '-' + arch\n  var packageResolutionError\n  try {\n    var prebuildPackage = path.dirname(require('module').createRequire(url.pathToFileURL(path.join(dir, 'package.json'))).resolve(platformPackage))\n    return resolveFile(prebuildPackage)\n  } catch(error) {\n    packageResolutionError = error\n  }\n\n  var target = [\n    'platform=' + platform,\n    'arch=' + arch,\n    'runtime=' + runtime,\n    'abi=' + abi,\n    'uv=' + uv,\n    armv ? 'armv=' + armv : '',\n    'libc=' + libc,\n    'node=' + process.versions.node,\n    process.versions.electron ? 'electron=' + process.versions.electron : '',\n    typeof __webpack_require__ === 'function' ? 'webpack=true' : '' // eslint-disable-line\n  ].filter(Boolean).join(' ')\n  let errMessage = 'No native build was found for ' + target + '\\n    attempted loading from: ' + dir + ' and package:' +\n    ' ' + platformPackage + '\\n';\n  if (packageNameError) {\n    errMessage += 'Error finding package.json: ' + packageNameError.message + '\\n';\n  }\n  if (packageResolutionError) {\n    errMessage += 'Error resolving package: ' + packageResolutionError.message + '\\n';\n  }\n  throw new Error(errMessage)\n\n  function resolve (dir) {\n    // Find matching \"prebuilds/<platform>-<arch>\" directory\n    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)\n    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]\n    if (!tuple) return\n    return resolveFile(path.join(dir, 'prebuilds', tuple.name))\n  }\n  function resolveFile (prebuilds) {\n    // Find most specific flavor first\n    var parsed = readdirSync(prebuilds).map(parseTags)\n    var candidates = parsed.filter(matchTags(runtime, abi))\n    var winner = candidates.sort(compareTags(runtime))[0]\n    if (winner) return path.join(prebuilds, winner.file)\n  }\n}\n\nfunction readdirSync (dir) {\n  try {\n    return fs.readdirSync(dir)\n  } catch (err) {\n    return []\n  }\n}\n\nfunction getFirst (dir, filter) {\n  var files = readdirSync(dir).filter(filter)\n  return files[0] && path.join(dir, files[0])\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction parseTuple (name) {\n  // Example: darwin-x64+arm64\n  var arr = name.split('-')\n  if (arr.length !== 2) return\n\n  var platform = arr[0]\n  var architectures = arr[1].split('+')\n\n  if (!platform) return\n  if (!architectures.length) return\n  if (!architectures.every(Boolean)) return\n\n  return { name, platform, architectures }\n}\n\nfunction matchTuple (platform, arch) {\n  return function (tuple) {\n    if (tuple == null) return false\n    if (tuple.platform !== platform) return false\n    return tuple.architectures.includes(arch)\n  }\n}\n\nfunction compareTuples (a, b) {\n  // Prefer single-arch prebuilds over multi-arch\n  return a.architectures.length - b.architectures.length\n}\n\nfunction parseTags (file) {\n  var arr = file.split('.')\n  var extension = arr.pop()\n  var tags = { file: file, specificity: 0 }\n\n  if (extension !== 'node') return\n\n  for (var i = 0; i < arr.length; i++) {\n    var tag = arr[i]\n\n    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {\n      tags.runtime = tag\n    } else if (tag === 'napi') {\n      tags.napi = true\n    } else if (tag.slice(0, 3) === 'abi') {\n      tags.abi = tag.slice(3)\n    } else if (tag.slice(0, 2) === 'uv') {\n      tags.uv = tag.slice(2)\n    } else if (tag.slice(0, 4) === 'armv') {\n      tags.armv = tag.slice(4)\n    } else if (tag === 'glibc' || tag === 'musl') {\n      tags.libc = tag\n    } else {\n      continue\n    }\n\n    tags.specificity++\n  }\n\n  return tags\n}\n\nfunction matchTags (runtime, abi) {\n  return function (tags) {\n    if (tags == null) return false\n    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false\n    if (tags.abi !== abi && !tags.napi) return false\n    if (tags.uv && tags.uv !== uv) return false\n    if (tags.armv && tags.armv !== armv) return false\n    if (tags.libc && tags.libc !== libc) return false\n\n    return true\n  }\n}\n\nfunction runtimeAgnostic (tags) {\n  return tags.runtime === 'node' && tags.napi\n}\n\nfunction compareTags (runtime) {\n  // Precedence: non-agnostic runtime, abi over napi, then by specificity.\n  return function (a, b) {\n    if (a.runtime !== b.runtime) {\n      return a.runtime === runtime ? -1 : 1\n    } else if (a.abi !== b.abi) {\n      return a.abi ? -1 : 1\n    } else if (a.specificity !== b.specificity) {\n      return a.specificity > b.specificity ? -1 : 1\n    } else {\n      return 0\n    }\n  }\n}\n\nfunction isNwjs () {\n  return !!(process.versions && process.versions.nw)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\nfunction isMusl (platform) {\n  if (platform !== 'linux') return false;\n  const { familySync, MUSL } = require('detect-libc');\n  return familySync() === MUSL;\n}\n\n// Exposed for unit tests\n// TODO: move to lib\nload.parseTags = parseTags\nload.matchTags = matchTags\nload.compareTags = compareTags\nload.parseTuple = parseTuple\nload.matchTuple = matchTuple\nload.compareTuples = compareTuples\n\n", "const runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\nif (typeof runtimeRequire.addon === 'function') { // if the platform supports native resolving prefer that\n  module.exports = runtimeRequire.addon.bind(runtimeRequire)\n} else { // else use the runtime version here\n  module.exports = require('./node-gyp-build.js')\n}\n", "module.exports = require('node-gyp-build-optional-packages')(__dirname);", "var fs = require('fs')\nvar path = require('path')\nvar url = require('url')\n\nvar vars = (process.config && process.config.variables) || {}\nvar prebuildsOnly = !!process.env.PREBUILDS_ONLY\nvar versions = process.versions\nvar abi = versions.modules\nif (versions.deno || process.isBun) {\n  // both Deno and Bun made the very poor decision to shoot themselves in the foot and lie about support for ABI\n  // (which they do not have)\n  abi = 'unsupported'\n}\nvar runtime = isElectron() ? 'electron' : 'node'\nvar arch = process.arch\nvar platform = process.platform\nvar libc = process.env.LIBC || (isMusl(platform) ? 'musl' : 'glibc')\nvar armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''\nvar uv = (versions.uv || '').split('.')[0]\n\nmodule.exports = load\n\nfunction load (dir) {\n  // Workaround to fix webpack's build warnings: 'the request of a dependency is an expression', but without\n  // reassigning require in a way that breaks Bun.\n  if (typeof __webpack_require__ === 'function')\n    return __non_webpack_require__(load.path(dir))\n  else\n    return require(load.path(dir))\n}\n\nload.path = function (dir) {\n  dir = path.resolve(dir || '.')\n  var packageName = ''\n  try {\n    // explanation above\n    if (typeof __webpack_require__ === 'function')\n      packageName = __non_webpack_require__(path.join(dir, 'package.json')).name\n    else\n      packageName = require(path.join(dir, 'package.json')).name\n    var varName = packageName.toUpperCase().replace(/-/g, '_') + '_PREBUILD'\n    if (process.env[varName]) dir = process.env[varName]\n  } catch (err) {}\n  if (!prebuildsOnly) {\n    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n    if (release) return release\n\n    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n    if (debug) return debug\n  }\n\n  var prebuild = resolve(dir)\n  if (prebuild) return prebuild\n\n  var nearby = resolve(path.dirname(process.execPath))\n  if (nearby) return nearby\n\n  var platformPackage = (packageName[0] == '@' ? '' : '@' + packageName + '/') + packageName + '-' + platform + '-' + arch\n  try {\n    var prebuildPackage = path.dirname(require('module').createRequire(url.pathToFileURL(path.join(dir, 'package.json'))).resolve(platformPackage))\n    return resolveFile(prebuildPackage)\n  } catch(error) {}\n\n  var target = [\n    'platform=' + platform,\n    'arch=' + arch,\n    'runtime=' + runtime,\n    'abi=' + abi,\n    'uv=' + uv,\n    armv ? 'armv=' + armv : '',\n    'libc=' + libc,\n    'node=' + process.versions.node,\n    process.versions.electron ? 'electron=' + process.versions.electron : '',\n    typeof __webpack_require__ === 'function' ? 'webpack=true' : '' // eslint-disable-line\n  ].filter(Boolean).join(' ')\n\n  throw new Error('No native build was found for ' + target + '\\n    attempted loading from: ' + dir + ' and package:' +\n     ' ' + platformPackage + '\\n')\n\n  function resolve (dir) {\n    // Find matching \"prebuilds/<platform>-<arch>\" directory\n    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)\n    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]\n    if (!tuple) return\n    return resolveFile(path.join(dir, 'prebuilds', tuple.name))\n  }\n  function resolveFile (prebuilds) {\n    // Find most specific flavor first\n    var parsed = readdirSync(prebuilds).map(parseTags)\n    var candidates = parsed.filter(matchTags(runtime, abi))\n    var winner = candidates.sort(compareTags(runtime))[0]\n    if (winner) return path.join(prebuilds, winner.file)\n  }\n}\n\nfunction readdirSync (dir) {\n  try {\n    return fs.readdirSync(dir)\n  } catch (err) {\n    return []\n  }\n}\n\nfunction getFirst (dir, filter) {\n  var files = readdirSync(dir).filter(filter)\n  return files[0] && path.join(dir, files[0])\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction parseTuple (name) {\n  // Example: darwin-x64+arm64\n  var arr = name.split('-')\n  if (arr.length !== 2) return\n\n  var platform = arr[0]\n  var architectures = arr[1].split('+')\n\n  if (!platform) return\n  if (!architectures.length) return\n  if (!architectures.every(Boolean)) return\n\n  return { name, platform, architectures }\n}\n\nfunction matchTuple (platform, arch) {\n  return function (tuple) {\n    if (tuple == null) return false\n    if (tuple.platform !== platform) return false\n    return tuple.architectures.includes(arch)\n  }\n}\n\nfunction compareTuples (a, b) {\n  // Prefer single-arch prebuilds over multi-arch\n  return a.architectures.length - b.architectures.length\n}\n\nfunction parseTags (file) {\n  var arr = file.split('.')\n  var extension = arr.pop()\n  var tags = { file: file, specificity: 0 }\n\n  if (extension !== 'node') return\n\n  for (var i = 0; i < arr.length; i++) {\n    var tag = arr[i]\n\n    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {\n      tags.runtime = tag\n    } else if (tag === 'napi') {\n      tags.napi = true\n    } else if (tag.slice(0, 3) === 'abi') {\n      tags.abi = tag.slice(3)\n    } else if (tag.slice(0, 2) === 'uv') {\n      tags.uv = tag.slice(2)\n    } else if (tag.slice(0, 4) === 'armv') {\n      tags.armv = tag.slice(4)\n    } else if (tag === 'glibc' || tag === 'musl') {\n      tags.libc = tag\n    } else {\n      continue\n    }\n\n    tags.specificity++\n  }\n\n  return tags\n}\n\nfunction matchTags (runtime, abi) {\n  return function (tags) {\n    if (tags == null) return false\n    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false\n    if (tags.abi !== abi && !tags.napi) return false\n    if (tags.uv && tags.uv !== uv) return false\n    if (tags.armv && tags.armv !== armv) return false\n    if (tags.libc && tags.libc !== libc) return false\n\n    return true\n  }\n}\n\nfunction runtimeAgnostic (tags) {\n  return tags.runtime === 'node' && tags.napi\n}\n\nfunction compareTags (runtime) {\n  // Precedence: non-agnostic runtime, abi over napi, then by specificity.\n  return function (a, b) {\n    if (a.runtime !== b.runtime) {\n      return a.runtime === runtime ? -1 : 1\n    } else if (a.abi !== b.abi) {\n      return a.abi ? -1 : 1\n    } else if (a.specificity !== b.specificity) {\n      return a.specificity > b.specificity ? -1 : 1\n    } else {\n      return 0\n    }\n  }\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\nfunction isMusl (platform) {\n  if (platform !== 'linux') return false;\n  const { familySync, MUSL } = require('detect-libc');\n  return familySync() === MUSL;\n}\n\n// Exposed for unit tests\n// TODO: move to lib\nload.parseTags = parseTags\nload.matchTags = matchTags\nload.compareTags = compareTags\nload.parseTuple = parseTuple\nload.matchTuple = matchTuple\nload.compareTuples = compareTuples", "module.exports = require('node-gyp-build-optional-packages')(__dirname)\n", "import express, { Request, Response, NextFunction } from 'express';\nimport https from 'node:https';\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport { loadData } from './loadData.js';\nimport { \n  jsonSerialize, \n  msgpackSerialize, \n  cborSerialize, \n  protoSerialize, \n  avroSerialize,\n  compressWithZstd\n} from './serializers.js';\nimport { Trip } from './types.js';\n\n// Setup paths\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst projectRoot = path.resolve(__dirname, '../../');\n\n// Configure SSL\nconst sslOptions = {\n  key: fs.readFileSync(path.join(projectRoot, 'self_signed_cert/localhost.key')),\n  cert: fs.readFileSync(path.join(projectRoot, 'self_signed_cert/localhost.crt'))\n};\n\n// Initialize the app\nconst app = express();\nconst PORT = 3001; // Using a different port from the Rust backend\n\n// Middleware to add security headers for high precision timers\napp.use((req: Request, res: Response, next: NextFunction) => {\n  res.set('Cross-Origin-Opener-Policy', 'same-origin');\n  res.set('Cross-Origin-Embedder-Policy', 'require-corp');\n  next();\n});\n\n// Middleware to log request stats\napp.use((req: Request, res: Response, next: NextFunction) => {\n  const start = process.hrtime.bigint();\n  res.on('finish', () => {\n    const end = process.hrtime.bigint();\n    const duration = Number((end - start) / 1000000n); // Convert to milliseconds\n    console.log(`${req.path} Request duration: ${duration}ms`);\n  });\n  next();\n});\n\n// Middleware for zstd compression if requested\napp.use((req: Request, res: Response, next: NextFunction) => {\n  const originalSend = res.send;\n  \n  res.send = function(body: any) {\n    if (req.headers['x-zstd-enabled'] === 'true') {\n      // Convert string to Buffer if needed\n      const dataToCompress = typeof body === 'string' ? Buffer.from(body) : body;\n      const compressed = compressWithZstd(dataToCompress);\n      res.set('Content-Encoding', 'zstd');\n      res.set('X-Zstd-Duration', compressed.duration.toString());\n      return originalSend.call(this, compressed.data);\n    }\n    return originalSend.call(this, body);\n  };\n  \n  next();\n});\n\n// Serve static frontend files\napp.use('/index.html', express.static(path.join(projectRoot, 'frontend/index.html')));\napp.use('/dist', express.static(path.join(projectRoot, 'frontend/dist')));\n\n// Load data before starting the server\nlet trips: Trip[] = [];\n\n// JSON endpoint\napp.get('/json', (req: Request, res: Response) => {\n  const result = jsonSerialize(trips);\n  res.set('X-Encode-Duration', result.duration.toString());\n  res.set('Content-Type', 'application/json; charset=utf-8');\n  res.send(result.data);\n});\n\n// MessagePack endpoint\napp.get('/msgpack', (req: Request, res: Response) => {\n  const result = msgpackSerialize(trips);\n  res.set('X-Encode-Duration', result.duration.toString());\n  res.type('application/octet-stream');\n  res.send(result.data);\n});\n\n// CBOR endpoint\napp.get('/cbor', (req: Request, res: Response) => {\n  const result = cborSerialize(trips);\n  res.set('X-Encode-Duration', result.duration.toString());\n  res.type('application/octet-stream');\n  res.send(result.data);\n});\n\n// Protocol Buffers endpoint\napp.get('/proto', (req: Request, res: Response) => {\n  const result = protoSerialize(trips);\n  res.set('X-Encode-Duration', result.duration.toString());\n  res.type('application/octet-stream');\n  res.send(result.data);\n});\n\n// Avro endpoint\napp.get('/avro', (req: Request, res: Response) => {\n  try {\n    const result = avroSerialize(trips);\n    res.set('X-Encode-Duration', result.duration.toString());\n    res.type('application/octet-stream');\n    res.send(result.data);\n  } catch (error) {\n    console.error('Error in Avro serialization:', error);\n    res.status(501).send('Avro serialization not fully implemented in this TypeScript/ESM version');\n  }\n});\n\n// Placeholder endpoints for formats we'll implement later if needed\napp.get('/bebop', (req: Request, res: Response) => {\n  res.status(501).send('Bebop serialization not yet implemented in Node.js backend');\n});\n\napp.get('/capnp', (req: Request, res: Response) => {\n  res.status(501).send('Cap\\'n Proto serialization not yet implemented in Node.js backend');\n});\n\napp.get('/flatbuffers', (req: Request, res: Response) => {\n  res.status(501).send('FlatBuffers serialization not yet implemented in Node.js backend');\n});\n\n// Start the server\nasync function startServer() {\n  console.log('Loading trip data...');\n  const startTime = process.hrtime.bigint();\n  \n  try {\n    trips = await loadData();\n    const endTime = process.hrtime.bigint();\n    const duration = Number((endTime - startTime) / 1000000n); // Convert to milliseconds\n    console.log(`Data loaded in ${duration}ms`);\n    \n    // Start HTTPS server\n    https.createServer(sslOptions, app).listen(PORT, () => {\n      console.log(`TypeScript Node.js backend server listening on https://localhost:${PORT}`);\n    });\n  } catch (error) {\n    console.error('Failed to load data:', error);\n    process.exit(1);\n  }\n}\n\nstartServer();", "import fs from 'node:fs';\nimport { createReadStream } from 'node:fs';\nimport path from 'node:path';\nimport csvParser from 'csv-parser';\nimport { RideableType, MemberCasual, stringToRideableType, stringToMemberCasual, parseDateTime } from './trip.js';\n\nexport async function loadData() {\n  const dataPath = path.resolve('../data/citibike-tripdata.csv');\n  const trips = [];\n  \n  return new Promise((resolve, reject) => {\n    createReadStream(dataPath)\n      .pipe(csvParser())\n      .on('data', (row) => {\n        // Parse and transform the CSV data into Trip objects\n        // Create base trip object\n        const trip = {\n          rideId: row.ride_id,\n          rideableType: stringToRideableType(row.rideable_type),\n          startedAt: parseDateTime(row.started_at),\n          endedAt: parseDateTime(row.ended_at),\n          memberCasual: stringToMemberCasual(row.member_casual)\n        };\n\n        // Add optional fields only if they exist and are not empty\n        if (row.start_station_name && row.start_station_name.trim()) {\n          trip.startStationName = row.start_station_name;\n        }\n        \n        if (row.start_station_id && row.start_station_id.trim()) {\n          trip.startStationId = String(row.start_station_id);\n        }\n        \n        if (row.end_station_name && row.end_station_name.trim()) {\n          trip.endStationName = row.end_station_name;\n        }\n        \n        if (row.end_station_id && row.end_station_id.trim()) {\n          trip.endStationId = String(row.end_station_id);\n        }\n\n        // Add latitude and longitude fields if they exist\n        if (row.start_lat && !isNaN(parseFloat(row.start_lat))) {\n          trip.startLat = parseFloat(row.start_lat);\n        }\n        \n        if (row.start_lng && !isNaN(parseFloat(row.start_lng))) {\n          trip.startLng = parseFloat(row.start_lng);\n        }\n        \n        if (row.end_lat && !isNaN(parseFloat(row.end_lat))) {\n          trip.endLat = parseFloat(row.end_lat);\n        }\n        \n        if (row.end_lng && !isNaN(parseFloat(row.end_lng))) {\n          trip.endLng = parseFloat(row.end_lng);\n        }\n        \n        trips.push(trip);\n      })\n      .on('end', () => {\n        console.log(`Loaded ${trips.length} trips`);\n        resolve(trips);\n      })\n      .on('error', (error) => {\n        reject(error);\n      });\n  });\n}", "// Constants for enum values\nexport const RideableType = {\n  UNKNOWN_RIDEABLE_TYPE: 0,\n  ELECTRIC_BIKE: 1,\n  CLASSIC_BIKE: 2\n};\n\nexport const MemberCasual = {\n  UNKNOWN_MEMBER_CASUAL: 0,\n  MEMBER: 1,\n  CASUAL: 2\n};\n\n// Helper function to convert string to RideableType enum\nexport function stringToRideableType(str) {\n  if (!str) return RideableType.UNKNOWN_RIDEABLE_TYPE;\n  \n  const normalized = str.toLowerCase().trim();\n  if (normalized === 'electric_bike') return RideableType.ELECTRIC_BIKE;\n  if (normalized === 'classic_bike') return RideableType.CLASSIC_BIKE;\n  return RideableType.UNKNOWN_RIDEABLE_TYPE;\n}\n\n// Helper function to convert string to MemberCasual enum\nexport function stringToMemberCasual(str) {\n  if (!str) return MemberCasual.UNKNOWN_MEMBER_CASUAL;\n  \n  const normalized = str.toLowerCase().trim();\n  if (normalized === 'member') return MemberCasual.MEMBER;\n  if (normalized === 'casual') return MemberCasual.CASUAL;\n  return MemberCasual.UNKNOWN_MEMBER_CASUAL;\n}\n\n// Parse a datetime string to milliseconds since epoch\nexport function parseDateTime(dateTimeStr) {\n  if (!dateTimeStr) return null;\n  \n  const dateObj = new Date(dateTimeStr);\n  return dateObj.getTime();\n}", "var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn asSafeString(read())\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nfunction asSafeString(property) {\n\t// protect against expensive (DoS) string conversions\n\tif (typeof property === 'string') return property;\n\tif (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();\n\tif (property == null) return property + '';\n\tthrow new Error('Invalid property type for record', typeof property);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(asSafeString) // ensure that all keys are strings and\n\t// that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x42] = (data) => {\n\t// decode bigint\n\tlet length = data.length;\n\tlet value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);\n\tfor (let i = 1; i < length; i++) {\n\t\tvalue <<= BigInt(8);\n\t\tvalue += BigInt(data[i]);\n\t}\n\treturn value;\n}\n\nlet errors = { Error, TypeError, ReferenceError };\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\treturn (errors[data[0]] || Error)(data[1], { cause: data[2] })\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName) {\n\t\tif (typeCode === 16) {\n\t\t\tlet ab = new ArrayBuffer(data.length - 1)\n\t\t\tlet u8 = new Uint8Array(ab)\n\t\t\tu8.set(data.subarray(1))\n\t\t\treturn ab;\n\t\t}\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t}\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\treturn new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)// TODO: Implement support for negative\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n} // notepack defines extension 0 to mean undefined, so use that as the default here\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n", "import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, target.byteLength - position)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end,\n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\t\t// don't keep large buffers around\n\t\t\t\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null\n\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\ttransitionsCount = 0\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = []\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = []\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\n\t\t\t\t\t\t\t// no extension found, write as plain object\n\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else if (this.largeBigIntToString) {\n\t\t\t\t\t\treturn pack(value.toString());\n\t\t\t\t\t} else if (this.useBigIntExtension && value < BigInt(2)**BigInt(1023) && value > -(BigInt(2)**BigInt(1023))) {\n\t\t\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t\ttarget[position++] = 0x42 // \"B\" for BigInt\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\tlet alignedSign;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tlet byte = value & BigInt(0xff);\n\t\t\t\t\t\t\talignedSign = (byte & BigInt(0x80)) === (value < BigInt(0) ? BigInt(0x80) : BigInt(0));\n\t\t\t\t\t\t\tbytes.push(byte);\n\t\t\t\t\t\t\tvalue >>= BigInt(8);\n\t\t\t\t\t\t} while (!((value === BigInt(0) || value === BigInt(-1)) && alignedSign));\n\t\t\t\t\t\ttarget[position-2] = bytes.length;\n\t\t\t\t\t\tfor (let i = bytes.length; i > 0;) {\n\t\t\t\t\t\t\ttarget[position++] = Number(bytes[--i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set' +\n\t\t\t\t\t\t\t' largeBigIntToString to convert to string')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys;\n\t\t\tif (this.skipValues) {\n\t\t\t\tkeys = [];\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tif ((typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) &&\n\t\t\t\t\t\t!this.skipValues.includes(object[key]))\n\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeys = Object.keys(object)\n\t\t\t}\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size > 0xffff) {\n\t\t\t\tthrow new Error('Object is too large to serialize with fast 16-bit map size,' +\n\t\t\t\t' use the \"variableMapSize\" option to serialize this object');\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t}\n\n\t\t// create reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\n\t\tconst writeObject = checkUseRecords ? (object) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object) : writePlainObject(object)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttarget.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength))\n\t\tposition = 0\n\t}\n\tset position (value) {\n\t\tposition = value;\n\t}\n\tget position() {\n\t\treturn position;\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message, error.cause ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\tif (!typedArray.buffer) typedArray = new Uint8Array(typedArray)\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const RESERVE_START_SPACE = 2048", "\n/*\n\nFor \"any-data\":\n32-55 - record with record ids (-32)\n56 - 8-bit record ids\n57 - 16-bit record ids\n58 - 24-bit record ids\n59 - 32-bit record ids\n250-255 - followed by typed fixed width values\n64-250 msgpackr/cbor/paired data\narrays and strings within arrays are handled by paired encoding\n\nStructure encoding:\n(type - string (using paired encoding))+\n\nType encoding\nencoding byte - fixed width byte - next reference+\n\nEncoding byte:\nfirst bit:\n\t0 - inline\n\t1 - reference\nsecond bit:\n\t0 - data or number\n\t1 - string\n\nremaining bits:\n\tcharacter encoding - ISO-8859-x\n\n\nnull (0xff)+ 0xf6\nnull (0xff)+ 0xf7\n\n*/\n\n\nimport {setWriteStructSlots, RECORD_SYMBOL, addExtension} from './pack.js'\nimport {setReadStruct, mult10, readString} from './unpack.js';\nconst ASCII = 3; // the MIBenum from https://www.iana.org/assignments/character-sets/character-sets.xhtml (and other character encodings could be referenced by MIBenum)\nconst NUMBER = 0;\nconst UTF8 = 2;\nconst OBJECT_DATA = 1;\nconst DATE = 16;\nconst TYPE_NAMES = ['num', 'object', 'string', 'ascii'];\nTYPE_NAMES[DATE] = 'date';\nconst float32Headers = [false, true, true, false, false, true, true, false];\nlet evalSupported;\ntry {\n\tnew Function('');\n\tevalSupported = true;\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n}\n\nlet updatedPosition;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nlet textEncoder, currentSource;\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nconst encodeUtf8 = hasNodeBuffer ? function(target, string, position) {\n\treturn target.utf8Write(string, position, target.byteLength - position)\n} : (textEncoder && textEncoder.encodeInto) ?\n\tfunction(target, string, position) {\n\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t} : false\n\nconst TYPE = Symbol('type');\nconst PARENT = Symbol('parent');\nsetWriteStructSlots(writeStruct, prepareStructures);\nfunction writeStruct(object, target, encodingStart, position, structures, makeRoom, pack, packr) {\n\tlet typedStructs = packr.typedStructs || (packr.typedStructs = []);\n\t// note that we rely on pack.js to load stored structures before we get to this point\n\tlet targetView = target.dataView;\n\tlet refsStartPosition = (typedStructs.lastStringStart || 100) + position;\n\tlet safeEnd = target.length - 10;\n\tlet start = position;\n\tif (position > safeEnd) {\n\t\ttarget = makeRoom(position);\n\t\ttargetView = target.dataView;\n\t\tposition -= encodingStart;\n\t\tstart -= encodingStart;\n\t\trefsStartPosition -= encodingStart;\n\t\tencodingStart = 0;\n\t\tsafeEnd = target.length - 10;\n\t}\n\n\tlet refOffset, refPosition = refsStartPosition;\n\n\tlet transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));\n\tlet nextId = typedStructs.nextId || typedStructs.length;\n\tlet headerSize =\n\t\tnextId < 0xf ? 1 :\n\t\t\tnextId < 0xf0 ? 2 :\n\t\t\t\tnextId < 0xf000 ? 3 :\n\t\t\t\t\tnextId < 0xf00000 ? 4 : 0;\n\tif (headerSize === 0)\n\t\treturn 0;\n\tposition += headerSize;\n\tlet queuedReferences = [];\n\tlet usedAscii0;\n\tlet keyIndex = 0;\n\tfor (let key in object) {\n\t\tlet value = object[key];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: 0,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null,\n\t\t\t\tdate64: null\n\t\t\t};\n\t\t}\n\t\tif (position > safeEnd) {\n\t\t\ttarget = makeRoom(position);\n\t\t\ttargetView = target.dataView;\n\t\t\tposition -= encodingStart;\n\t\t\tstart -= encodingStart;\n\t\t\trefsStartPosition -= encodingStart;\n\t\t\trefPosition -= encodingStart;\n\t\t\tencodingStart = 0;\n\t\t\tsafeEnd = target.length - 10\n\t\t}\n\t\tswitch (typeof value) {\n\t\t\tcase 'number':\n\t\t\t\tlet number = value;\n\t\t\t\t// first check to see if we are using a lot of ids and should default to wide/common format\n\t\t\t\tif (nextId < 200 || !nextTransition.num64) {\n\t\t\t\t\tif (number >> 0 === number && number < 0x20000000 && number > -0x1f000000) {\n\t\t\t\t\t\tif (number < 0xf6 && number >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number < 0x20 && !nextTransition.num32)) {\n\t\t\t\t\t\t\ttransition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\t\t\t\ttarget[position++] = number;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\ttargetView.setUint32(position, number, true);\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (number < 0x100000000 && number >= -0x80000000) {\n\t\t\t\t\t\ttargetView.setFloat32(position, number, true);\n\t\t\t\t\t\tif (float32Headers[target[position + 3] >>> 5]) {\n\t\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\tif (((xShifted = number * mult10[((target[position + 3] & 0x7f) << 1) | (target[position + 2] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);\n\t\t\t\ttargetView.setFloat64(position, number, true);\n\t\t\t\tposition += 8;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tlet strLength = value.length;\n\t\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\t\tif ((strLength << 2) + refPosition > safeEnd) {\n\t\t\t\t\ttarget = makeRoom((strLength << 2) + refPosition);\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tposition -= encodingStart;\n\t\t\t\t\tstart -= encodingStart;\n\t\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\t\trefPosition -= encodingStart;\n\t\t\t\t\tencodingStart = 0;\n\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t}\n\t\t\t\tif (strLength > ((0xff00 + refOffset) >> 2)) {\n\t\t\t\t\tqueuedReferences.push(key, value, position - start);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet isNotAscii\n\t\t\t\tlet strStart = refPosition;\n\t\t\t\tif (strLength < 0x40) {\n\t\t\t\t\tlet i, c1, c2;\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[refPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trefPosition += encodeUtf8(target, value, refPosition);\n\t\t\t\t\tisNotAscii = refPosition - strStart > strLength;\n\t\t\t\t}\n\t\t\t\tif (refOffset < 0xa0 || (refOffset < 0xf6 && (nextTransition.ascii8 || nextTransition.string8))) {\n\t\t\t\t\t// short strings\n\t\t\t\t\tif (isNotAscii) {\n\t\t\t\t\t\tif (!(transition = nextTransition.string8)) {\n\t\t\t\t\t\t\tif (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {\n\t\t\t\t\t\t\t\t// we can safely change ascii to utf8 in place since they are compatible\n\t\t\t\t\t\t\t\ttransition.__type = UTF8;\n\t\t\t\t\t\t\t\tnextTransition.ascii8 = null;\n\t\t\t\t\t\t\t\tnextTransition.string8 = transition;\n\t\t\t\t\t\t\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, UTF8, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (refOffset === 0 && !usedAscii0) {\n\t\t\t\t\t\tusedAscii0 = true;\n\t\t\t\t\t\ttransition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);\n\t\t\t\t\t\tbreak; // don't increment position\n\t\t\t\t\t}// else ascii:\n\t\t\t\t\telse if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8)))\n\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, ASCII, 1);\n\t\t\t\t\ttarget[position++] = refOffset;\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Enable ascii16 at some point, but get the logic right\n\t\t\t\t\t//if (isNotAscii)\n\t\t\t\t\t\ttransition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);\n\t\t\t\t\t//else\n\t\t\t\t\t\t//transition = nextTransition.ascii16 || createTypeTransition(nextTransition, ASCII, 2);\n\t\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\t\tposition += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (value) {\n\t\t\t\t\tif (value.constructor === Date) {\n\t\t\t\t\t\ttransition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);\n\t\t\t\t\t\ttargetView.setFloat64(position, value.getTime(), true);\n\t\t\t\t\t\tposition += 8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else { // null\n\t\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -10); // match CBOR with this\n\t\t\t\t\tif (nextTransition) {\n\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\t\ttransition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\ttarget[position++] = value ? 0xf9 : 0xf8; // match CBOR with these\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -9); // match CBOR with this\n\t\t\t\tif (nextTransition) {\n\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\tfor (let i = 0, l = queuedReferences.length; i < l;) {\n\t\tlet key = queuedReferences[i++];\n\t\tlet value = queuedReferences[i++];\n\t\tlet propertyIndex = queuedReferences[i++];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: propertyIndex - keyIndex,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null\n\t\t\t};\n\t\t}\n\t\tlet newPosition;\n\t\tif (value) {\n\t\t\t/*if (typeof value === 'string') { // TODO: we could re-enable long strings\n\t\t\t\tif (position + value.length * 3 > safeEnd) {\n\t\t\t\t\ttarget = makeRoom(position + value.length * 3);\n\t\t\t\t\tposition -= start;\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\tnewPosition = position + target.utf8Write(value, position, 0xffffffff);\n\t\t\t} else { */\n\t\t\tlet size;\n\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\tif (refOffset < 0xff00) {\n\t\t\t\ttransition = nextTransition.object16;\n\t\t\t\tif (transition)\n\t\t\t\t\tsize = 2;\n\t\t\t\telse if ((transition = nextTransition.object32))\n\t\t\t\t\tsize = 4;\n\t\t\t\telse {\n\t\t\t\t\ttransition = createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\t\t\tsize = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttransition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);\n\t\t\t\tsize = 4;\n\t\t\t}\n\t\t\tnewPosition = pack(value, refPosition);\n\t\t\t//}\n\t\t\tif (typeof newPosition === 'object') {\n\t\t\t\t// re-allocated\n\t\t\t\trefPosition = newPosition.position;\n\t\t\t\ttargetView = newPosition.targetView;\n\t\t\t\ttarget = newPosition.target;\n\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\tposition -= encodingStart;\n\t\t\t\tstart -= encodingStart;\n\t\t\t\tencodingStart = 0;\n\t\t\t} else\n\t\t\t\trefPosition = newPosition;\n\t\t\tif (size === 2) {\n\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\tposition += 2;\n\t\t\t} else {\n\t\t\t\ttargetView.setUint32(position, refOffset, true);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t} else { // null or undefined\n\t\t\ttransition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\ttargetView.setInt16(position, value === null ? -10 : -9, true);\n\t\t\tposition += 2;\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\n\tlet recordId = transition[RECORD_SYMBOL];\n\tif (recordId == null) {\n\t\trecordId = packr.typedStructs.length;\n\t\tlet structure = [];\n\t\tlet nextTransition = transition;\n\t\tlet key, type;\n\t\twhile ((type = nextTransition.__type) !== undefined) {\n\t\t\tlet size = nextTransition.__size;\n\t\t\tnextTransition = nextTransition.__parent;\n\t\t\tkey = nextTransition.key;\n\t\t\tlet property = [type, size, key];\n\t\t\tif (nextTransition.enumerationOffset)\n\t\t\t\tproperty.push(nextTransition.enumerationOffset);\n\t\t\tstructure.push(property);\n\t\t\tnextTransition = nextTransition.parent;\n\t\t}\n\t\tstructure.reverse();\n\t\ttransition[RECORD_SYMBOL] = recordId;\n\t\tpackr.typedStructs[recordId] = structure;\n\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t}\n\n\n\tswitch (headerSize) {\n\t\tcase 1:\n\t\t\tif (recordId >= 0x10) return 0;\n\t\t\ttarget[start] = recordId + 0x20;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (recordId >= 0x100) return 0;\n\t\t\ttarget[start] = 0x38;\n\t\t\ttarget[start + 1] = recordId;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (recordId >= 0x10000) return 0;\n\t\t\ttarget[start] = 0x39;\n\t\t\ttargetView.setUint16(start + 1, recordId, true);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (recordId >= 0x1000000) return 0;\n\t\t\ttargetView.setUint32(start, (recordId << 8) + 0x3a, true);\n\t\t\tbreak;\n\t}\n\n\tif (position < refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\t// adjust positioning\n\t\ttarget.copyWithin(position, refsStartPosition, refPosition);\n\t\trefPosition += position - refsStartPosition;\n\t\ttypedStructs.lastStringStart = position - start;\n\t} else if (position > refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\ttypedStructs.lastStringStart = position - start;\n\t\treturn writeStruct(object, target, encodingStart, start, structures, makeRoom, pack, packr);\n\t}\n\treturn refPosition;\n}\nfunction anyType(transition, position, targetView, value) {\n\tlet nextTransition;\n\tif ((nextTransition = transition.ascii8 || transition.num8)) {\n\t\ttargetView.setInt8(position, value, true);\n\t\tupdatedPosition = position + 1;\n\t\treturn nextTransition;\n\t}\n\tif ((nextTransition = transition.string16 || transition.object16)) {\n\t\ttargetView.setInt16(position, value, true);\n\t\tupdatedPosition = position + 2;\n\t\treturn nextTransition;\n\t}\n\tif (nextTransition = transition.num32) {\n\t\ttargetView.setUint32(position, 0xe0000100 + value, true);\n\t\tupdatedPosition = position + 4;\n\t\treturn nextTransition;\n\t}\n\t// transition.float64\n\tif (nextTransition = transition.num64) {\n\t\ttargetView.setFloat64(position, NaN, true);\n\t\ttargetView.setInt8(position, value);\n\t\tupdatedPosition = position + 8;\n\t\treturn nextTransition;\n\t}\n\tupdatedPosition = position;\n\t// TODO: can we do an \"any\" type where we defer the decision?\n\treturn;\n}\nfunction createTypeTransition(transition, type, size) {\n\tlet typeName = TYPE_NAMES[type] + (size << 3);\n\tlet newTransition = transition[typeName] || (transition[typeName] = Object.create(null));\n\tnewTransition.__type = type;\n\tnewTransition.__size = size;\n\tnewTransition.__parent = transition;\n\treturn newTransition;\n}\nfunction onLoadedStructures(sharedData) {\n\tif (!(sharedData instanceof Map))\n\t\treturn sharedData;\n\tlet typed = sharedData.get('typed') || [];\n\tif (Object.isFrozen(typed))\n\t\ttyped = typed.map(structure => structure.slice(0));\n\tlet named = sharedData.get('named');\n\tlet transitions = Object.create(null);\n\tfor (let i = 0, l = typed.length; i < l; i++) {\n\t\tlet structure = typed[i];\n\t\tlet transition = transitions;\n\t\tfor (let [type, size, key] of structure) {\n\t\t\tlet nextTransition = transition[key];\n\t\t\tif (!nextTransition) {\n\t\t\t\ttransition[key] = nextTransition = {\n\t\t\t\t\tkey,\n\t\t\t\t\tparent: transition,\n\t\t\t\t\tenumerationOffset: 0,\n\t\t\t\t\tascii0: null,\n\t\t\t\t\tascii8: null,\n\t\t\t\t\tnum8: null,\n\t\t\t\t\tstring16: null,\n\t\t\t\t\tobject16: null,\n\t\t\t\t\tnum32: null,\n\t\t\t\t\tfloat64: null,\n\t\t\t\t\tdate64: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\ttransition = createTypeTransition(nextTransition, type, size);\n\t\t}\n\t\ttransition[RECORD_SYMBOL] = i;\n\t}\n\ttyped.transitions = transitions;\n\tthis.typedStructs = typed;\n\tthis.lastTypedStructuresLength = typed.length;\n\treturn named;\n}\nvar sourceSymbol = Symbol.for('source')\nfunction readStruct(src, position, srcEnd, unpackr) {\n\tlet recordId = src[position++] - 0x20;\n\tif (recordId >= 24) {\n\t\tswitch(recordId) {\n\t\t\tcase 24: recordId = src[position++]; break;\n\t\t\t// little endian:\n\t\t\tcase 25: recordId = src[position++] + (src[position++] << 8); break;\n\t\t\tcase 26: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16); break;\n\t\t\tcase 27: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16) + (src[position++] << 24); break;\n\t\t}\n\t}\n\tlet structure = unpackr.typedStructs && unpackr.typedStructs[recordId];\n\tif (!structure) {\n\t\t// copy src buffer because getStructures will override it\n\t\tsrc = Uint8Array.prototype.slice.call(src, position, srcEnd);\n\t\tsrcEnd -= position;\n\t\tposition = 0;\n\t\tif (!unpackr.getStructures)\n\t\t\tthrow new Error(`Reference to shared structure ${recordId} without getStructures method`);\n\t\tunpackr._mergeStructures(unpackr.getStructures());\n\t\tif (!unpackr.typedStructs)\n\t\t\tthrow new Error('Could not find any shared typed structures');\n\t\tunpackr.lastTypedStructuresLength = unpackr.typedStructs.length;\n\t\tstructure = unpackr.typedStructs[recordId];\n\t\tif (!structure)\n\t\t\tthrow new Error('Could not find typed structure ' + recordId);\n\t}\n\tvar construct = structure.construct;\n\tif (!construct) {\n\t\tconstruct = structure.construct = function LazyObject() {\n\t\t}\n\t\tvar prototype = construct.prototype;\n\t\tlet properties = [];\n\t\tlet currentOffset = 0;\n\t\tlet lastRefProperty;\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet definition = structure[i];\n\t\t\tlet [ type, size, key, enumerationOffset ] = definition;\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tlet property = {\n\t\t\t\tkey,\n\t\t\t\toffset: currentOffset,\n\t\t\t}\n\t\t\tif (enumerationOffset)\n\t\t\t\tproperties.splice(i + enumerationOffset, 0, property);\n\t\t\telse\n\t\t\t\tproperties.push(property);\n\t\t\tlet getRef;\n\t\t\tswitch(size) { // TODO: Move into a separate function\n\t\t\t\tcase 0: getRef = () => 0; break;\n\t\t\t\tcase 1:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet ref = source.bytes[position + property.offset];\n\t\t\t\t\t\treturn ref >= 0xf6 ? toConstant(ref) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint16(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint32(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xffffff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tproperty.getRef = getRef;\n\t\t\tcurrentOffset += size;\n\t\t\tlet get;\n\t\t\tswitch(type) {\n\t\t\t\tcase ASCII:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tproperty.multiGetCount = 0;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (source.srcString) {\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*if (property.multiGetCount > 0) {\n\t\t\t\t\t\t\tlet asciiEnd;\n\t\t\t\t\t\t\tnext = firstRefProperty;\n\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tasciiEnd = dataView.getUint16(source.position + next.offset, true);\n\t\t\t\t\t\t\t\tif (asciiEnd < 0xff00)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tasciiEnd = null;\n\t\t\t\t\t\t\t} while((next = next.next));\n\t\t\t\t\t\t\tif (asciiEnd == null)\n\t\t\t\t\t\t\t\tasciiEnd = source.bytesEnd - refStart\n\t\t\t\t\t\t\tsource.srcString = src.toString('latin1', refStart, refStart + asciiEnd);\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (source.prevStringGet) {\n\t\t\t\t\t\t\tsource.prevStringGet.multiGetCount += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.prevStringGet = property;\n\t\t\t\t\t\t\tproperty.multiGetCount--;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\treturn readString(src, ref + refStart, end - ref);\n\t\t\t\t\t\t//return src.toString('latin1', ref + refStart, end + refStart);\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase UTF8: case OBJECT_DATA:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (type === UTF8) {\n\t\t\t\t\t\t\treturn src.toString('utf8', ref + refStart, end + refStart);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentSource = source;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn unpackr.unpack(src, { start: ref + refStart, end: end + refStart });\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tcurrentSource = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase NUMBER:\n\t\t\t\t\tswitch(size) {\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet position = source.position + property.offset;\n\t\t\t\t\t\t\t\tlet value = dataView.getInt32(position, true)\n\t\t\t\t\t\t\t\tif (value < 0x20000000) {\n\t\t\t\t\t\t\t\t\tif (value > -0x1f000000)\n\t\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t\tif (value > -0x20000000)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(value & 0xff);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet fValue = dataView.getFloat32(position, true);\n\t\t\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\tlet multiplier = mult10[((src[position + 3] & 0x7f) << 1) | (src[position + 2] >> 7)]\n\t\t\t\t\t\t\t\treturn ((multiplier * fValue + (fValue > 0 ? 0.5 : -0.5)) >> 0) / multiplier;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet value = dataView.getFloat64(source.position + property.offset, true);\n\t\t\t\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\t\t\t\tlet byte = src[source.position + property.offset];\n\t\t\t\t\t\t\t\t\tif (byte >= 0xf6)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(byte);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet value = src[source.position + property.offset];\n\t\t\t\t\t\t\t\treturn value < 0xf6 ? value : toConstant(value);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DATE:\n\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\treturn new Date(dataView.getFloat64(source.position + property.offset, true));\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tproperty.get = get;\n\t\t}\n\t\t// TODO: load the srcString for faster string decoding on toJSON\n\t\tif (evalSupported) {\n\t\t\tlet objectLiteralProperties = [];\n\t\t\tlet args = [];\n\t\t\tlet i = 0;\n\t\t\tlet hasInheritedProperties;\n\t\t\tfor (let property of properties) { // assign in enumeration order\n\t\t\t\tif (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {\n\t\t\t\t\t// these properties are not eagerly evaluated and this can be used for creating properties\n\t\t\t\t\t// that are not serialized as JSON\n\t\t\t\t\thasInheritedProperties = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tObject.defineProperty(prototype, property.key, { get: withSource(property.get), enumerable: true });\n\t\t\t\tlet valueFunction = 'v' + i++;\n\t\t\t\targs.push(valueFunction);\n\t\t\t\tobjectLiteralProperties.push('[' + JSON.stringify(property.key) + ']:' + valueFunction + '(s)');\n\t\t\t}\n\t\t\tif (hasInheritedProperties) {\n\t\t\t\tobjectLiteralProperties.push('__proto__:this');\n\t\t\t}\n\t\t\tlet toObject = (new Function(...args, 'return function(s){return{' + objectLiteralProperties.join(',') + '}}')).apply(null, properties.map(prop => prop.get));\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\treturn toObject.call(this, this[sourceSymbol]);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\t// return an enumerable object with own properties to JSON stringify\n\t\t\t\t\tlet resolved = {};\n\t\t\t\t\tfor (let i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t// TODO: check alwaysLazyProperty\n\t\t\t\t\t\tlet key = properties[i].key;\n\n\t\t\t\t\t\tresolved[key] = this[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t},\n\t\t\t\t// not enumerable or anything\n\t\t\t});\n\t\t}\n\t}\n\tvar instance = new construct();\n\tinstance[sourceSymbol] = {\n\t\tbytes: src,\n\t\tposition,\n\t\tsrcString: '',\n\t\tbytesEnd: srcEnd\n\t}\n\treturn instance;\n}\nfunction toConstant(code) {\n\tswitch(code) {\n\t\tcase 0xf6: return null;\n\t\tcase 0xf7: return undefined;\n\t\tcase 0xf8: return false;\n\t\tcase 0xf9: return true;\n\t}\n\tthrow new Error('Unknown constant');\n}\nfunction withSource(get) {\n\treturn function() {\n\t\treturn get(this[sourceSymbol]);\n\t}\n}\n\nfunction saveState() {\n\tif (currentSource) {\n\t\tcurrentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);\n\t\tcurrentSource.position = 0;\n\t\tcurrentSource.bytesEnd = currentSource.bytes.length;\n\t}\n}\nfunction prepareStructures(structures, packr) {\n\tif (packr.typedStructs) {\n\t\tlet structMap = new Map();\n\t\tstructMap.set('named', structures);\n\t\tstructMap.set('typed', packr.typedStructs);\n\t\tstructures = structMap;\n\t}\n\tlet lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;\n\tstructures.isCompatible = existing => {\n\t\tlet compatible = true;\n\t\tif (existing instanceof Map) {\n\t\t\tlet named = existing.get('named') || [];\n\t\t\tif (named.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t\tlet typed = existing.get('typed') || [];\n\t\t\tif (typed.length !== lastTypedStructuresLength)\n\t\t\t\tcompatible = false;\n\t\t} else if (existing instanceof Array || Array.isArray(existing)) {\n\t\t\tif (existing.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t}\n\t\tif (!compatible)\n\t\t\tpackr._mergeStructures(existing);\n\t\treturn compatible;\n\t};\n\tpackr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;\n\treturn structures;\n}\n\nsetReadStruct(readStruct, onLoadedStructures, saveState);\n\n", "export { Packr, Encoder, addExtension, pack, encode, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } from './pack.js'\nexport { Unpackr, Decoder, C1, unpack, unpackMultiple, decode, FLOAT32_OPTIONS, clearSource, roundFloat32, isNativeAccelerationEnabled } from './unpack.js'\nimport './struct.js'\nexport { PackrStream, UnpackrStream, PackrStream as EncoderStream, UnpackrStream as DecoderStream } from './stream.js'\nexport { decodeIter, encodeIter } from './iterators.js'\nexport const useRecords = false\nexport const mapsAsObjects = true\nimport { setExtractor } from './unpack.js'\nimport { createRequire } from 'module'\n\nconst nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === 'true';\n\nif (!nativeAccelerationDisabled) {\n\tlet extractor\n\ttry {\n\t\tif (typeof require == 'function')\n\t\t\textractor = require('msgpackr-extract')\n\t\telse\n\t\t\textractor = createRequire(import.meta.url)('msgpackr-extract')\n\t\tif (extractor)\n\t\t\tsetExtractor(extractor.extractStrings)\n\t} catch (error) {\n\t\t// native module is optional\n\t}\n}", "let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet maxArraySize = 112810000 // This is the maximum array size in V8. We would potentially detect and set it higher\n// for JSC, but this is pretty large and should be sufficient for most use cases\nlet maxMapSize = 16810000 // JavaScript has a fixed maximum map size of about 16710000, but JS itself enforces this,\n// so we don't need to\n\nlet maxObjectSize = 16710000; // This is the maximum number of keys in a Map. It takes over a minute to create this\n// many keys in an object, so also probably a reasonable choice there.\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\n\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) && !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared && !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r => this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end > -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues &&\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position >= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token >> 5\n\ttoken = token & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType > 1) {\n\t\t\t\t\tif (dataView.getUint32(position) > 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tif (i >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) {\n\t\t\t\t\t\t\t\twhile((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n\t\t\t\t\t\t\t\t\tobject[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\twhile ((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n\t\t\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) {\n\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\twhile((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Map size exceeds ${maxMapSize}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmap.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\twhile ((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Map size exceeds ${maxMapSize}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmap.set(key, read())\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd >= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tif (token >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i < token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (token >= maxMapSize) throw new Error(`Map size exceeds ${maxArraySize}`)\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i < token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token >= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token & 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token < 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the\n\t\t\t\t\t\t// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tlet structure = read()\n\t\t\t\t\t\trecordDefinition(id, structure)\n\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\tif (currentDecoder.keyMap) for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = structure[i - 2]\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn object\n\t\t\t\t\t}\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\trecordDefinition(id++, read())\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token & 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i < currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tif (!structure) throw new Error('Structure is required in record definition');\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token >> 5\n\t\tlength = length & 0x1f\n\t\tif (length > 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ >= inlineObjectReadThreshold) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i < length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\t// protect against prototype pollution\n\tif (typeof key === 'string') return key === '__proto__' ? '__proto_' : key\n\tif (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') return key.toString();\n\tif (key == null) return key + '';\n\t// protect against expensive (DoS) string conversions\n\tthrow new Error('Invalid property name type ' + typeof key);\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 & 0x7f) >> 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 & 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 & 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n\t\treturn (byte0 & 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 & 0x80) | // sign bit\n\t\t((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 >> 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 << 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0x60 && length < 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) => {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i < l; i++) {\n\t\tvalue = BigInt(buffer[i]) + (value << BigInt(8))\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) => {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) => {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n\tid = id - 0xe000\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n\tlet length = data.length\n\tlet structure = data[1]\n\trecordDefinition(data[0], structure)\n\tlet object = {}\n\tfor (let i = 2; i < length; i++) {\n\t\tlet key = structure[i - 2]\n\t\tobject[safeKey(key)] = data[i]\n\t}\n\treturn object\n}\ncurrentExtensions[14] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n\tif (src[position++] != 0x84) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\tif (src.length < position)\n\t\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tlet newPackedValues = read() // packed values\n\tif (!newPackedValues || !newPackedValues.length) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]\n\tlet error = new Error('No support for non-integer packed references yet')\n\tif (data === undefined)\n\t\terror.incomplete = true\n\tthrow error\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet startingPosition = position\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token >> 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) {// there is a cycle, so we have to assign properties to original target\n\t\tif (Object.getPrototypeOf(target) !== Object.getPrototypeOf(targetProperties)) {\n\t\t\t// this means that the returned target does not match the targetProperties, so we need rerun the read to\n\t\t\t// have the correctly create instance be assigned as a reference, then we do the copy the properties back to the\n\t\t\t// target\n\t\t\t// reset the position so that the read can be repeated\n\t\t\tposition = startingPosition\n\t\t\t// the returned instance is our new target for references\n\t\t\ttarget = targetProperties\n\t\t\treferenceMap.set(id, { target })\n\t\t\ttargetProperties = read()\n\t\t}\n\t\treturn Object.assign(target, targetProperties)\n\t}\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) => {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n\tif (tag >= 225 && tag <= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag >= 28704 && tag <= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag >= 1879052288 && tag <= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag >= 216 && tag <= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag >= 27647 && tag <= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag >= 1811940352 && tag <= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tlet bytesPerElement;\n\tif (typeof TypedArray === 'function')\n\t\tbytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n\telse\n\t\tTypedArray = null;\n\tfor (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n\t\tif (!littleEndian && bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : bytesPerElement == 8 ? 3 : 0\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tif (!currentDecoder.copyBuffers) {\n\t\t\t\t// try provide a direct view, but will only work if we are byte-aligned\n\t\t\t\tif (bytesPerElement === 1 ||\n\t\t\t\t\tbytesPerElement === 2 && !(buffer.byteOffset & 1) ||\n\t\t\t\t\tbytesPerElement === 4 && !(buffer.byteOffset & 3) ||\n\t\t\t\t\tbytesPerElement === 8 && !(buffer.byteOffset & 7))\n\t\t\t\t\treturn new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength >> sizeShift);\n\t\t\t}\n\t\t\t// we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length >> sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i < elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i << sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i < length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() => {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport function setSizeLimits(limits) {\n\tif (limits.maxMapSize) maxMapSize = limits.maxMapSize;\n\tif (limits.maxArraySize) maxArraySize = limits.maxArraySize;\n\tif (limits.maxObjectSize) maxObjectSize = limits.maxObjectSize;\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n", "import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet sharedStructures\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\toptions = options || {}\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n\t\t\treturn target.utf8Write(string, position, maxBytes)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet encoder = this\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 128 : 0\n\t\tif (maxSharedStructures > 8190)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8190')\n\t\tlet isSequential = options.sequential\n\t\tif (isSequential) {\n\t\t\tmaxSharedStructures = 0\n\t\t}\n\t\tif (!this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.saveStructures)\n\t\t\tthis.saveShared = this.saveStructures\n\t\tlet samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues\n\t\tlet sharedPackedObjectMap\n\t\tif (sharedValues) {\n\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++) {\n\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t}\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\t\t\n\t\tthis.mapEncode = function(value, encodeOptions) {\n\t\t\t// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n\t\t\tif (this._keyMap && !this._mapped) {\n\t\t\t\t//console.log('encoding ', value)\n\t\t\t\tswitch (value.constructor.name) {\n\t\t\t\t\tcase 'Array': \n\t\t\t\t\t\tvalue = value.map(r => this.encodeKeys(r))\n\t\t\t\t\t\tbreak\n\t\t\t\t\t//case 'Map': \n\t\t\t\t\t//\tvalue = this.encodeKeys(value)\n\t\t\t\t\t//\tbreak\n\t\t\t\t}\n\t\t\t\t//this._mapped = true\n\t\t\t}\n\t\t\treturn this.encode(value, encodeOptions)\n\t\t}\n\t\t\n\t\tthis.encode = function(value, encodeOptions)\t{\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else if (encodeOptions === REUSE_BUFFER_MODE)\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encoder.useSelfDescribedHeader) {\n\t\t\t\ttargetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n\t\t\t\tposition += 3\n\t\t\t}\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\n\t\t\tif (encoder.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\n\t\t\tsharedStructures = encoder.structures\n\t\t\tif (sharedStructures) {\n\t\t\t\tif (sharedStructures.uninitialized) {\n\t\t\t\t\tlet sharedData = encoder.getShared() || {}\n\t\t\t\t\tencoder.structures = sharedStructures = sharedData.structures || []\n\t\t\t\t\tencoder.sharedVersion = sharedData.version\n\t\t\t\t\tlet sharedValues = encoder.sharedValues = sharedData.packedValues\n\t\t\t\t\tif (sharedValues) {\n\t\t\t\t\t\tsharedPackedObjectMap = {}\n\t\t\t\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++)\n\t\t\t\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\n\t\t\t\tif (sharedStructuresLength > maxSharedStructures && !isSequential)\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\n\t\t\t\tif (!sharedStructures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\n\t\t\t\t\t\tlet keys = sharedStructures[i]\n\t\t\t\t\t\t//console.log('shared struct keys:', keys)\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined)\n\t\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i | 0x100000\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isSequential)\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tstructures = sharedStructures || []\n\t\t\tpackedObjectMap = sharedPackedObjectMap\n\t\t\tif (options.pack) {\n\t\t\t\tlet packedValues = new Map()\n\t\t\t\tpackedValues.values = []\n\t\t\t\tpackedValues.encoder = encoder\n\t\t\t\tpackedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity)\n\t\t\t\tpackedValues.objectMap = sharedPackedObjectMap || false\n\t\t\t\tpackedValues.samplingPackedValues = samplingPackedValues\n\t\t\t\tfindRepetitiveStrings(value, packedValues)\n\t\t\t\tif (packedValues.values.length > 0) {\n\t\t\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\twriteArrayHeader(4)\n\t\t\t\t\tlet valuesArray = packedValues.values\n\t\t\t\t\tencode(valuesArray)\n\t\t\t\t\twriteArrayHeader(0) // prefixes\n\t\t\t\t\twriteArrayHeader(0) // suffixes\n\t\t\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowOnIterable = encodeOptions & THROW_ON_ITERABLE;\n\t\t\ttry {\n\t\t\t\tif (throwOnIterable)\n\t\t\t\t\treturn;\n\t\t\t\tencode(value)\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\twriteBundles(start, encode)\n\t\t\t\t}\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 2\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tencoder.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (sharedStructures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tif (sharedStructures.length > maxSharedStructures)\n\t\t\t\t\t\tsharedStructures.length = maxSharedStructures\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tsharedStructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t\t//sharedStructures.nextId = maxSharedStructures\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasSharedUpdate && encoder.saveShared) {\n\t\t\t\t\tif (encoder.structures.length > maxSharedStructures) {\n\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\n\t\t\t\t\t}\n\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\tif (encoder.updateSharedData() === false)\n\t\t\t\t\t\treturn encoder.encode(value) // re-encode if it fails\n\t\t\t\t\treturn returnBuffer\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tthis.findCommonStringsToPack = () => {\n\t\t\tsamplingPackedValues = new Map()\n\t\t\tif (!sharedPackedObjectMap)\n\t\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\treturn (options) => {\n\t\t\t\tlet threshold = options && options.threshold || 4\n\t\t\t\tlet position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n\t\t\t\tif (!sharedValues)\n\t\t\t\t\tsharedValues = this.sharedValues = []\n\t\t\t\tfor (let [ key, status ] of samplingPackedValues) {\n\t\t\t\t\tif (status.count > threshold) {\n\t\t\t\t\t\tsharedPackedObjectMap[key] = position++\n\t\t\t\t\t\tsharedValues.push(key)\n\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (this.saveShared && this.updateSharedData() === false) {}\n\t\t\t\tsamplingPackedValues = null\n\t\t\t}\n\t\t}\n\t\tconst encode = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tif (packedObjectMap) {\n\t\t\t\t\tlet packedPosition = packedObjectMap[value]\n\t\t\t\t\tif (packedPosition >= 0) {\n\t\t\t\t\t\tif (packedPosition < 16)\n\t\t\t\t\t\t\ttarget[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\t\tif (packedPosition & 1)\n\t\t\t\t\t\t\t\tencode((15 - packedPosition) >> 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tencode((packedPosition - 16) >> 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n/*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n\t\t\t\t\t} else if (samplingPackedValues && !options.pack) {\n\t\t\t\t\t\tlet status = samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsamplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x400) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\ttarget[position++] = 0xd9 // tag 16-bit\n\t\t\t\t\t\ttarget[position++] = 0xdf // tag 0xdff9\n\t\t\t\t\t\ttarget[position++] = 0xf9\n\t\t\t\t\t\t// TODO: If we only have one bundle with any string data, only write one string bundle\n\t\t\t\t\t\ttarget[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n\t\t\t\t\t\ttarget[position++] = 0x1a // 32-bit unsigned int\n\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\tif (bundledStrings.position) {\n\t\t\t\t\t\t\twriteBundles(start, encode) // write the last bundles\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = twoByte ? 0xce : 0xcf\n\t\t\t\t\tencode(strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x18) {\n\t\t\t\t\ttarget[position++] = 0x60 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x78\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x79\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x7a\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (!this.alwaysUseFloat && value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x18) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x18\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x19\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x1a\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (!this.alwaysUseFloat && value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x18) {\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\n\t\t\t\t\t} else if (value >= -0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x38\n\t\t\t\t\t\ttarget[position++] = ~value\n\t\t\t\t\t} else if (value >= -0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x39\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x3a\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xfa\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xf6\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\ttarget[position++] = 29 // http://cbor.schmorp.de/value-sharing\n\t\t\t\t\t\t\ttarget[position++] = 0x19 // 16-bit uint\n\t\t\t\t\t\t\tif (!referee.references) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.references = []\n\t\t\t\t\t\t\t\tidsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treferee.references.push(position - start)\n\t\t\t\t\t\t\tposition += 2 // TODO: also support 32-bit\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tlength = value.length\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteArrayHeader(length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\t\tencode(value[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n\t\t\t\t\t\t\t// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\ttarget[position++] = 1\n\t\t\t\t\t\t\ttarget[position++] = 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\t\t\t\ttarget[position++] = length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xba\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoder.keyMap) { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(key) \n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tlet tag = extension.tag\n\t\t\t\t\t\t\t\tif (tag == undefined)\n\t\t\t\t\t\t\t\t\ttag = extension.getTag && extension.getTag.call(this, value)\n\t\t\t\t\t\t\t\tif (tag < 0x18) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x100) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x10000) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag >> 8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag & 0xff\n\t\t\t\t\t\t\t\t} else if (tag > -1) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\n\t\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode, makeRoom)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.iterator]) {\n\t\t\t\t\t\t\tif (throwOnIterable) {\n\t\t\t\t\t\t\t\tlet error = new Error('Iterable should be serialized as iterator')\n\t\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0x9f // indefinite length array\n\t\t\t\t\t\t\tfor (let entry of value) {\n\t\t\t\t\t\t\t\tencode(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xff // stop-code\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.asyncIterator] || isBlob(value)) {\n\t\t\t\t\t\t\tlet error = new Error('Iterable/blob should be serialized as iterator')\n\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.useToJSON && value.toJSON) {\n\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\treturn encode(json)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// no extension found, write as a plain object\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(64)) && value >= 0) {\n\t\t\t\t\t// use an unsigned int as long as it fits\n\t\t\t\t\ttarget[position++] = 0x1b\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else if (value > -(BigInt(1)<<BigInt(64)) && value < 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0x3b\n\t\t\t\t\ttargetView.setBigUint64(position, -value - BigInt(1))\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (value >= BigInt(0))\n\t\t\t\t\t\t\ttarget[position++] = 0xc2 // tag 2\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc3 // tag 2\n\t\t\t\t\t\t\tvalue = BigInt(-1) - value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\twhile (value) {\n\t\t\t\t\t\t\tbytes.push(Number(value & BigInt(0xff)));\n\t\t\t\t\t\t\tvalue >>= BigInt(8);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twriteBuffer(new Uint8Array(bytes.reverse()), makeRoom);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\ttarget[position++] = 0xf7\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet vals = Object.values(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x18) {\n\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t} else if (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xba\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(encoder.encodeKey(keys[i]))\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(keys[i])\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tif (encoder.keyMap) {\n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\t\tencode(key)\n\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(object, skipValues) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tlet length = 0\n\t\t\tlet parentRecordId\n\t\t\tlet keys\n\t\t\tif (this.keyMap) {\n\t\t\t\tkeys = Object.keys(object).map(k => this.encodeKey(k))\n\t\t\t\tlength = keys.length\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] & 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n\t\t\t\t\t\t\tparentRecordId = transition[RECORD_SYMBOL] & 0xffff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId !== undefined) {\n\t\t\t\trecordId &= 0xffff\n\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t} else {\n\t\t\t\tif (!keys)\n\t\t\t\t\tkeys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n\t\t\t\tif (parentRecordId === undefined) {\n\t\t\t\t\trecordId = structures.nextId++\n\t\t\t\t\tif (!recordId) {\n\t\t\t\t\t\trecordId = 0\n\t\t\t\t\t\tstructures.nextId = 1\n\t\t\t\t\t}\n\t\t\t\t\tif (recordId >= MAX_STRUCTURES) {// cycle back around\n\t\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures) + 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trecordId = parentRecordId\n\t\t\t\t}\n\t\t\t\tstructures[recordId] = keys\n\t\t\t\tif (recordId < maxSharedStructures) {\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] & 0x100000))\n\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\t\ttransition = transition[keys[i]]\n\t\t\t\t\t}\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\ttargetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n\t\t\t\t\tposition += 3\n\t\t\t\t\tif (newTransitions)\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\t\tif (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n\t\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\t\twriteArrayHeader(length + 2)\n\t\t\t\t\tencode(0xe000 + recordId)\n\t\t\t\t\tencode(keys)\n\t\t\t\t\tif (skipValues) return; // special exit for iterator\n\t\t\t\t\tfor (let key in object)\n\t\t\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))\n\t\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (length < 0x18) { // write the array header\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else {\n\t\t\t\twriteArrayHeader(length)\n\t\t\t}\n\t\t\tif (skipValues) return; // special exit for iterator\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))\n\t\t\t\t\tencode(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Encoded buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tlet chunkThreshold = 100;\n\t\tlet continuedChunkThreshold = 1000;\n\t\tthis.encodeAsIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsIterable);\n\t\t}\n\t\tthis.encodeAsAsyncIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsAsyncIterable);\n\t\t}\n\n\t\tfunction* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n\t\t\tlet constructor = object.constructor;\n\t\t\tif (constructor === Object) {\n\t\t\t\tlet useRecords = encoder.useRecords !== false;\n\t\t\t\tif (useRecords)\n\t\t\t\t\twriteObject(object, true); // write the record identifier\n\t\t\t\telse\n\t\t\t\t\twriteEntityLength(Object.keys(object).length, 0xa0);\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tlet value = object[key];\n\t\t\t\t\tif (!useRecords) encode(key);\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tif (iterateProperties[key])\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties[key]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, key);\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (constructor === Array) {\n\t\t\t\tlet length = object.length;\n\t\t\t\twriteArrayHeader(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet value = object[i];\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (object[Symbol.iterator] && !object.buffer) { // iterator, but exclude typed arrays\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tfor (let value of object) {\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else if (isBlob(object)){\n\t\t\t\twriteEntityLength(object.size, 0x40); // encode as binary data\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return blobs, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t} else if (object[Symbol.asyncIterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return async iterators, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else {\n\t\t\t\tencode(object);\n\t\t\t}\n\t\t\tif (finalIterable && position > start) yield target.subarray(start, position);\n\t\t\telse if (position - start > chunkThreshold) {\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\trestartEncoding();\n\t\t\t}\n\t\t}\n\t\tfunction* tryEncode(value, iterateProperties, key) {\n\t\t\tlet restart = position - start;\n\t\t\ttry {\n\t\t\t\tencode(value);\n\t\t\t\tif (position - start > chunkThreshold) {\n\t\t\t\t\tyield target.subarray(start, position);\n\t\t\t\t\trestartEncoding();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error.iteratorNotHandled) {\n\t\t\t\t\titerateProperties[key] = {};\n\t\t\t\t\tposition = start + restart; // restart our position so we don't have partial data from last encode\n\t\t\t\t\tyield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t}\n\t\tfunction restartEncoding() {\n\t\t\tchunkThreshold = continuedChunkThreshold;\n\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n\t\t}\n\t\tfunction startEncoding(value, options, encodeIterable) {\n\t\t\tif (options && options.chunkThreshold) // explicitly specified chunk sizes\n\t\t\t\tchunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n\t\t\telse // we start with a smaller threshold to get initial bytes sent quickly\n\t\t\t\tchunkThreshold = 100;\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // start encoding\n\t\t\t\treturn encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n\t\t\t}\n\t\t\treturn [encoder.encode(value)];\n\t\t}\n\n\t\tasync function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n\t\t\tfor (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n\t\t\t\tlet constructor = encodedValue.constructor;\n\t\t\t\tif (constructor === ByteArray || constructor === Uint8Array)\n\t\t\t\t\tyield encodedValue;\n\t\t\t\telse if (isBlob(encodedValue)) {\n\t\t\t\t\tlet reader = encodedValue.stream().getReader();\n\t\t\t\t\tlet next;\n\t\t\t\t\twhile (!(next = await reader.read()).done) {\n\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t}\n\t\t\t\t} else if (encodedValue[Symbol.asyncIterator]) {\n\t\t\t\t\tfor await (let asyncValue of encodedValue) {\n\t\t\t\t\t\trestartEncoding();\n\t\t\t\t\t\tif (asyncValue)\n\t\t\t\t\t\t\tyield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n\t\t\t\t\t\telse yield encoder.encode(asyncValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tyield encodedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.sharedValues)\n\t\t\tthis.sharedValues = undefined\n\t}\n\tupdateSharedData() {\n\t\tlet lastVersion = this.sharedVersion || 0\n\t\tthis.sharedVersion = lastVersion + 1\n\t\tlet structuresCopy = this.structures.slice(0)\n\t\tlet sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n\t\tlet saveResults = this.saveShared(sharedData,\n\t\t\t\texistingShared => (existingShared && existingShared.version || 0) == lastVersion)\n\t\tif (saveResults === false) {\n\t\t\t// get updated structures and try again if the update failed\n\t\t\tsharedData = this.getShared() || {}\n\t\t\tthis.structures = sharedData.structures || []\n\t\t\tthis.sharedValues = sharedData.packedValues\n\t\t\tthis.sharedVersion = sharedData.version\n\t\t\tthis.structures.nextId = this.structures.length\n\t\t} else {\n\t\t\t// restore structures\n\t\t\tstructuresCopy.forEach((structure, i) => this.structures[i] = structure)\n\t\t}\n\t\t// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n\t\treturn saveResults\n\t}\n}\nfunction writeEntityLength(length, majorValue) {\n\tif (length < 0x18)\n\t\ttarget[position++] = majorValue | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = majorValue | 0x18\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = majorValue | 0x19\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = majorValue | 0x1a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\n}\nclass SharedData {\n\tconstructor(structures, values, version) {\n\t\tthis.structures = structures\n\t\tthis.packedValues = values\n\t\tthis.version = version\n\t}\n}\n\nfunction writeArrayHeader(length) {\n\tif (length < 0x18)\n\t\ttarget[position++] = 0x80 | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = 0x98\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x99\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x9a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;\nfunction isBlob(object) {\n\tif (object instanceof BlobConstructor)\n\t\treturn true;\n\tlet tag = object[Symbol.toStringTag];\n\treturn tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n\tswitch(typeof value) {\n\t\tcase 'string':\n\t\t\tif (value.length > 3) {\n\t\t\t\tif (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues)\n\t\t\t\t\treturn\n\t\t\t\tlet packedStatus = packedValues.get(value)\n\t\t\t\tif (packedStatus) {\n\t\t\t\t\tif (++packedStatus.count == 2) {\n\t\t\t\t\t\tpackedValues.values.push(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpackedValues.set(value, {\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t})\n\t\t\t\t\tif (packedValues.samplingPackedValues) {\n\t\t\t\t\t\tlet status = packedValues.samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpackedValues.samplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'object':\n\t\t\tif (value) {\n\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\tfor (let i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\t\tfindRepetitiveStrings(value[i], packedValues)\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tlet includeKeys = !packedValues.encoder.useRecords\n\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tif (includeKeys)\n\t\t\t\t\t\t\t\tfindRepetitiveStrings(key, packedValues)\n\t\t\t\t\t\t\tfindRepetitiveStrings(value[key], packedValues)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'function': console.log(value)\n\t}\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nextensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,\n\tUint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,\n\tFloat32Array, Float64Array, SharedData ]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{ // Date\n\ttag: 1,\n\tencode(date, encode) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\ttarget[position++] = 0x1a\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t\tposition += 4\n\t\t} else {\n\t\t\t// Timestamp float64\n\t\t\ttarget[position++] = 0xfb\n\t\t\ttargetView.setFloat64(position, seconds)\n\t\t\tposition += 8\n\t\t}\n\t}\n}, { // Set\n\ttag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n\tencode(set, encode) {\n\t\tlet array = Array.from(set)\n\t\tencode(array)\n\t}\n}, { // Error\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(error, encode) {\n\t\tencode([ error.name, error.message ])\n\t}\n}, { // RegExp\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(regex, encode) {\n\t\tencode([ 'RegExp', regex.source, regex.flags ])\n\t}\n}, { // Tag\n\tgetTag(tag) {\n\t\treturn tag.tag\n\t},\n\tencode(tag, encode) {\n\t\tencode(tag.value)\n\t}\n}, { // ArrayBuffer\n\tencode(arrayBuffer, encode, makeRoom) {\n\t\twriteBuffer(arrayBuffer, makeRoom)\n\t}\n}, { // Uint8Array\n\tgetTag(typedArray) {\n\t\tif (typedArray.constructor === Uint8Array) {\n\t\t\tif (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)\n\t\t\t\treturn 64;\n\t\t} // else no tag\n\t},\n\tencode(typedArray, encode, makeRoom) {\n\t\twriteBuffer(typedArray, makeRoom)\n\t}\n},\n\ttypedArrayEncoder(68, 1),\n\ttypedArrayEncoder(69, 2),\n\ttypedArrayEncoder(70, 4),\n\ttypedArrayEncoder(71, 8),\n\ttypedArrayEncoder(72, 1),\n\ttypedArrayEncoder(77, 2),\n\ttypedArrayEncoder(78, 4),\n\ttypedArrayEncoder(79, 8),\n\ttypedArrayEncoder(85, 4),\n\ttypedArrayEncoder(86, 8),\n{\n\tencode(sharedData, encode) { // write SharedData\n\t\tlet packedValues = sharedData.packedValues || []\n\t\tlet sharedStructures = sharedData.structures || []\n\t\tif (packedValues.values.length > 0) {\n\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\twriteArrayHeader(4)\n\t\t\tlet valuesArray = packedValues.values\n\t\t\tencode(valuesArray)\n\t\t\twriteArrayHeader(0) // prefixes\n\t\t\twriteArrayHeader(0) // suffixes\n\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t}\n\t\t}\n\t\tif (sharedStructures) {\n\t\t\ttargetView.setUint32(position, 0xd9dffe00)\n\t\t\tposition += 3\n\t\t\tlet definitions = sharedStructures.slice(0)\n\t\t\tdefinitions.unshift(0xe000)\n\t\t\tdefinitions.push(new Tag(sharedData.version, 0x53687264))\n\t\t\tencode(definitions)\n\t\t} else\n\t\t\tencode(new Tag(sharedData.version, 0x53687264))\n\t\t}\n\t}]\nfunction typedArrayEncoder(tag, size) {\n\tif (!isLittleEndianMachine && size > 1)\n\t\ttag -= 4 // the big endian equivalents are 4 less\n\treturn {\n\t\ttag: tag,\n\t\tencode: function writeExtBuffer(typedArray, encode) {\n\t\t\tlet length = typedArray.byteLength\n\t\t\tlet offset = typedArray.byteOffset || 0\n\t\t\tlet buffer = typedArray.buffer || typedArray\n\t\t\tencode(hasNodeBuffer ? Buffer.from(buffer, offset, length) :\n\t\t\t\tnew Uint8Array(buffer, offset, length))\n\t\t}\n\t}\n}\nfunction writeBuffer(buffer, makeRoom) {\n\tlet length = buffer.byteLength\n\tif (length < 0x18) {\n\t\ttarget[position++] = 0x40 + length\n\t} else if (length < 0x100) {\n\t\ttarget[position++] = 0x58\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x59\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x5a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\tif (position + length >= target.length) {\n\t\tmakeRoom(position + length)\n\t}\n\t// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n\t// must wrap it to set it.\n\ttarget.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n\tposition += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 2\n\tlet lastEnd = serialized.length - distanceToMove\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\n\tfor (let id = 0; id < idsToInsert.length; id++) {\n\t\tlet referee = idsToInsert[id]\n\t\treferee.id = id\n\t\tfor (let position of referee.references) {\n\t\t\tserialized[position++] = id >> 8\n\t\t\tserialized[position] = id & 0xff\n\t\t}\n\t}\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 2\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd8\n\t\tserialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\nfunction writeBundles(start, encode) {\n\ttargetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n\tlet writeStrings = bundledStrings\n\tbundledStrings = null\n\tencode(writeStrings[0])\n\tencode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.encode)\n\t\t\tthrow new Error('Extension has no encode function')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tdecodeAddExtension(extension)\n}\nlet defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nimport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n\n\n", "export { Encoder, addExtension, encode, encodeAsIterable, encodeAsAsyncIterable, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT, REUSE_BUFFER_MODE } from './encode.js'\nexport { Tag, Decoder, decodeMultiple, decode, FLOAT32_OPTIONS, clearSource, roundFloat32, isNativeAccelerationEnabled, setSizeLimits } from './decode.js'\nexport { EncoderStream, DecoderStream } from './stream.js'\nexport { decodeIter, encodeIter } from './iterators.js'\nexport const useRecords = false\nexport const mapsAsObjects = true\nimport { setExtractor } from './decode.js'\nimport { createRequire } from 'module'\n\nconst nativeAccelerationDisabled = process.env.CBOR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.CBOR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === 'true';\n\nif (!nativeAccelerationDisabled) {\n\tlet extractor\n\ttry {\n\t\tif (typeof require == 'function')\n\t\t\textractor = require('cbor-extract')\n\t\telse\n\t\t\textractor = createRequire(import.meta.url)('cbor-extract')\n\t\tif (extractor)\n\t\t\tsetExtractor(extractor.extractStrings)\n\t} catch (error) {\n\t\t// native module is optional\n\t}\n}\n", "import { Packr } from 'msgpackr';\nimport { encode as cborEncode } from 'cbor-x';\nimport { readFileSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport { Encoder } from '@toondepauw/node-zstd';\nimport protobuf from 'protobufjs';\nimport avsc from 'avsc';\n\n// Shared state for serializers that need initialization\nlet avroSchema = null;\nlet protoRoot = null;\nlet flatbuffersSchema = null;\n\n// Lazy initialization of serialization schemas\nfunction initSerializers() {\n  if (!protoRoot) {\n    // Initialize protobuf schema\n    protoRoot = protobuf.loadSync(resolve('../schemas/trip.proto'));\n  }\n  \n  if (!avroSchema) {\n    // Initialize Avro schema\n    try {\n      const schemaJson = JSON.parse(readFileSync(resolve('../schemas/trip.avsc'), 'utf8'));\n      avroSchema = avsc.Type.forSchema(schemaJson);\n    } catch (error) {\n      console.error('Error loading Avro schema:', error);\n    }\n  }\n}\n\n// JSON Serializer\nexport function jsonSerialize(trips) {\n  const response = { trips };\n  const startTime = process.hrtime.bigint();\n  const serialized = JSON.stringify(response);\n  const endTime = process.hrtime.bigint();\n  \n  return {\n    data: serialized,\n    duration: Number((endTime - startTime) / 1000000n) // Convert to milliseconds\n  };\n}\n\n// MessagePack Serializer\nexport function msgpackSerialize(trips) {\n  const response = { trips };\n  const packr = new Packr();\n  \n  const startTime = process.hrtime.bigint();\n  const serialized = packr.pack(response);\n  const endTime = process.hrtime.bigint();\n  \n  return {\n    data: serialized,\n    duration: Number((endTime - startTime) / 1000000n)\n  };\n}\n\n// CBOR Serializer\nexport function cborSerialize(trips) {\n  const response = { trips };\n  \n  const startTime = process.hrtime.bigint();\n  const serialized = cborEncode(response);\n  const endTime = process.hrtime.bigint();\n  \n  return {\n    data: serialized,\n    duration: Number((endTime - startTime) / 1000000n)\n  };\n}\n\n// Protocol Buffers Serializer\nexport function protoSerialize(trips) {\n  initSerializers();\n  \n  const TripMessage = protoRoot.lookupType('trip_protobuf.Trip');\n  const ServerResponseAll = protoRoot.lookupType('trip_protobuf.ServerResponseAll');\n  \n  // Convert trips to protobuf format\n  const startTime = process.hrtime.bigint();\n  \n  const protoTrips = trips.map(trip => {\n    return TripMessage.create({\n      rideId: trip.rideId,\n      rideableType: trip.rideableType,\n      startedAtMs: trip.startedAt, // Using the new field name but proto expects startedAtMs\n      endedAtMs: trip.endedAt,     // Using the new field name but proto expects endedAtMs\n      startStationName: trip.startStationName,\n      startStationId: trip.startStationId,\n      endStationName: trip.endStationName,\n      endStationId: trip.endStationId,\n      startLat: trip.startLat,\n      startLng: trip.startLng, \n      endLat: trip.endLat,\n      endLng: trip.endLng,\n      memberCasual: trip.memberCasual\n    });\n  });\n  \n  const response = ServerResponseAll.create({ trips: protoTrips });\n  const serialized = ServerResponseAll.encode(response).finish();\n  const endTime = process.hrtime.bigint();\n  \n  return {\n    data: Buffer.from(serialized),\n    duration: Number((endTime - startTime) / 1000000n)\n  };\n}\n\n// Avro Serializer\nexport function avroSerialize(trips) {\n  initSerializers();\n  \n  if (!avroSchema) {\n    throw new Error('Avro schema not initialized');\n  }\n  \n  const response = { trips };\n  \n  const startTime = process.hrtime.bigint();\n  const serialized = avroSchema.toBuffer(response);\n  const endTime = process.hrtime.bigint();\n  \n  return {\n    data: serialized,\n    duration: Number((endTime - startTime) / 1000000n)\n  };\n}\n\n// Compression using zstd\nexport function compressWithZstd(data) {\n  const startTime = process.hrtime.bigint();\n  // Compression level 3 to match the Rust implementation\n  const encoder = new Encoder(3);\n  const compressed = encoder.encodeSync(data);\n  const endTime = process.hrtime.bigint();\n  \n  return {\n    data: compressed,\n    duration: Number((endTime - startTime) / 1000000n)\n  };\n}\n"],
  "mappings": "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",
  "names": ["fs", "readFileSync", "path", "resolve", "readFileSync", "resolve", "family", "version", "fs", "path", "resolve", "target", "dir", "platform", "arch", "runtime", "abi", "require_node_gyp_build_optional_packages", "fs", "path", "resolve", "target", "dir", "platform", "arch", "runtime", "abi", "fs", "path", "trips", "resolve", "readObject", "readString", "target", "saveState", "position", "bundledStrings", "referenceMap", "encodeUtf8", "writeStruct", "pack", "maxBytes", "key", "newPosition", "target", "targetView", "encode", "hasNodeBuffer", "textEncoder", "target", "position", "prepareStructures", "pack", "targetView", "safeEnd", "onLoadedStructures", "readStruct", "src", "srcEnd", "dataView", "saveState", "decoder", "src", "srcEnd", "position", "EMPTY_ARRAY", "strings", "EMPTY_ARRAY", "stringPosition", "currentStructures", "srcString", "srcStringStart", "srcStringEnd", "bundledStrings", "referenceMap", "currentExtensions", "dataView", "defaultOptions", "sequentialMode", "inlineObjectReadThreshold", "inlineObjectReadThreshold", "Decoder", "src", "saveState", "clearSource", "defaultOptions", "srcEnd", "position", "stringPosition", "srcStringEnd", "srcString", "strings", "EMPTY_ARRAY", "bundledStrings", "dataView", "currentStructures", "checkedRead", "sequentialMode", "checkedRead", "read", "bundledStrings", "position", "srcEnd", "currentStructures", "src", "referenceMap", "sequentialMode", "clearSource", "dataView", "mult10", "i", "readBin", "srcStringEnd", "srcString", "srcStringStart", "shortStringInJS", "longStringInJS", "readFixedString", "createStructureReader", "structure", "recordDefinition", "currentExtensions", "validName", "inlineObjectReadThreshold", "readStringJS", "readString8", "readString16", "readString32", "isNativeAccelerationEnabled", "setExtractor", "readString", "strings", "stringPosition", "EMPTY_ARRAY", "decoder", "fromCharCode", "f32Array", "u8Array", "src", "position", "keyCache", "currentExtensions", "recordDefinition", "currentStructures", "createStructureReader", "bundledStrings", "glbl", "read", "src", "position", "referenceMap", "target", "typedArrays", "readStringJS", "dataView", "saveState", "srcEnd", "stringPosition", "srcStringStart", "srcStringEnd", "srcString", "strings", "sequentialMode", "clearSource", "mult10", "Decoder", "decode", "FLOAT32_OPTIONS", "textEncoder", "extensions", "extensionClasses", "Buffer", "hasNodeBuffer", "ByteArrayAllocate", "ByteArray", "MAX_BUFFER_SIZE", "target", "targetView", "position", "safeEnd", "bundledStrings", "MAX_BUNDLE_SIZE", "hasNonLatin", "RECORD_SYMBOL", "Encoder", "Decoder", "referenceMap", "encodeUtf8", "ByteArray", "textEncoder", "packedObjectMap", "sharedPackedObjectMap", "ByteArrayAllocate", "REUSE_BUFFER_MODE", "sharedValues", "packedValues", "encode", "writeBundles", "insertIds", "RESET_BUFFER_MODE", "options", "maxBytes", "mult10", "extensions", "extensionClasses", "writeBuffer", "MAX_BUFFER_SIZE", "isLittleEndianMachine", "hasNodeBuffer", "writeExtBuffer", "Buffer", "Encoder", "encode", "NEVER", "ALWAYS", "DECIMAL_ROUND", "DECIMAL_FIT", "FLOAT32_OPTIONS", "REUSE_BUFFER_MODE", "RESET_BUFFER_MODE", "createRequire", "nativeAccelerationDisabled", "createRequire", "setExtractor", "Encoder", "trips", "encode", "Encoder", "__dirname", "path", "fs"]
}
