// automatically generated by the FlatBuffers compiler, do not modify

// @generated

extern crate flatbuffers;

#[allow(unused_imports, dead_code)]
pub mod trip {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_RIDEABLE_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_RIDEABLE_TYPE: i8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_RIDEABLE_TYPE: [RideableType; 3] = [
        RideableType::UNKNOWN_RIDEABLE_TYPE,
        RideableType::ELECTRIC_BIKE,
        RideableType::CLASSIC_BIKE,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct RideableType(pub i8);
    #[allow(non_upper_case_globals)]
    impl RideableType {
        pub const UNKNOWN_RIDEABLE_TYPE: Self = Self(0);
        pub const ELECTRIC_BIKE: Self = Self(1);
        pub const CLASSIC_BIKE: Self = Self(2);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::UNKNOWN_RIDEABLE_TYPE,
            Self::ELECTRIC_BIKE,
            Self::CLASSIC_BIKE,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::UNKNOWN_RIDEABLE_TYPE => Some("UNKNOWN_RIDEABLE_TYPE"),
                Self::ELECTRIC_BIKE => Some("ELECTRIC_BIKE"),
                Self::CLASSIC_BIKE => Some("CLASSIC_BIKE"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for RideableType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for RideableType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for RideableType {
        type Output = RideableType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for RideableType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for RideableType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for RideableType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_MEMBER_CASUAL: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_MEMBER_CASUAL: i8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_MEMBER_CASUAL: [MemberCasual; 3] = [
        MemberCasual::UNKNOWN_MEMBER_CASUAL,
        MemberCasual::MEMBER,
        MemberCasual::CASUAL,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct MemberCasual(pub i8);
    #[allow(non_upper_case_globals)]
    impl MemberCasual {
        pub const UNKNOWN_MEMBER_CASUAL: Self = Self(0);
        pub const MEMBER: Self = Self(1);
        pub const CASUAL: Self = Self(2);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 2;
        pub const ENUM_VALUES: &'static [Self] =
            &[Self::UNKNOWN_MEMBER_CASUAL, Self::MEMBER, Self::CASUAL];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::UNKNOWN_MEMBER_CASUAL => Some("UNKNOWN_MEMBER_CASUAL"),
                Self::MEMBER => Some("MEMBER"),
                Self::CASUAL => Some("CASUAL"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for MemberCasual {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for MemberCasual {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for MemberCasual {
        type Output = MemberCasual;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for MemberCasual {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for MemberCasual {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MemberCasual {}
    pub enum TripOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Trip<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Trip<'a> {
        type Inner = Trip<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Trip<'a> {
        pub const VT_RIDE_ID: flatbuffers::VOffsetT = 4;
        pub const VT_RIDEABLE_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_STARTED_AT_MS: flatbuffers::VOffsetT = 8;
        pub const VT_ENDED_AT_MS: flatbuffers::VOffsetT = 10;
        pub const VT_START_STATION_NAME: flatbuffers::VOffsetT = 12;
        pub const VT_START_STATION_ID: flatbuffers::VOffsetT = 14;
        pub const VT_END_STATION_NAME: flatbuffers::VOffsetT = 16;
        pub const VT_END_STATION_ID: flatbuffers::VOffsetT = 18;
        pub const VT_START_LAT: flatbuffers::VOffsetT = 20;
        pub const VT_START_LNG: flatbuffers::VOffsetT = 22;
        pub const VT_END_LAT: flatbuffers::VOffsetT = 24;
        pub const VT_END_LNG: flatbuffers::VOffsetT = 26;
        pub const VT_MEMBER_CASUAL: flatbuffers::VOffsetT = 28;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Trip { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TripArgs<'args>,
        ) -> flatbuffers::WIPOffset<Trip<'bldr>> {
            let mut builder = TripBuilder::new(_fbb);
            builder.add_end_lng(args.end_lng);
            builder.add_end_lat(args.end_lat);
            builder.add_start_lng(args.start_lng);
            builder.add_start_lat(args.start_lat);
            builder.add_ended_at_ms(args.ended_at_ms);
            builder.add_started_at_ms(args.started_at_ms);
            if let Some(x) = args.end_station_id {
                builder.add_end_station_id(x);
            }
            if let Some(x) = args.end_station_name {
                builder.add_end_station_name(x);
            }
            if let Some(x) = args.start_station_id {
                builder.add_start_station_id(x);
            }
            if let Some(x) = args.start_station_name {
                builder.add_start_station_name(x);
            }
            if let Some(x) = args.ride_id {
                builder.add_ride_id(x);
            }
            builder.add_member_casual(args.member_casual);
            builder.add_rideable_type(args.rideable_type);
            builder.finish()
        }

        #[inline]
        pub fn ride_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Trip::VT_RIDE_ID, None)
            }
        }
        #[inline]
        pub fn rideable_type(&self) -> RideableType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<RideableType>(
                        Trip::VT_RIDEABLE_TYPE,
                        Some(RideableType::UNKNOWN_RIDEABLE_TYPE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn started_at_ms(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(Trip::VT_STARTED_AT_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn ended_at_ms(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i64>(Trip::VT_ENDED_AT_MS, Some(0)).unwrap() }
        }
        #[inline]
        pub fn start_station_name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Trip::VT_START_STATION_NAME, None)
            }
        }
        #[inline]
        pub fn start_station_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Trip::VT_START_STATION_ID, None)
            }
        }
        #[inline]
        pub fn end_station_name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Trip::VT_END_STATION_NAME, None)
            }
        }
        #[inline]
        pub fn end_station_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Trip::VT_END_STATION_ID, None)
            }
        }
        #[inline]
        pub fn start_lat(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<f64>(Trip::VT_START_LAT, Some(0.0)).unwrap() }
        }
        #[inline]
        pub fn start_lng(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<f64>(Trip::VT_START_LNG, Some(0.0)).unwrap() }
        }
        #[inline]
        pub fn end_lat(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<f64>(Trip::VT_END_LAT, Some(0.0)).unwrap() }
        }
        #[inline]
        pub fn end_lng(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<f64>(Trip::VT_END_LNG, Some(0.0)).unwrap() }
        }
        #[inline]
        pub fn member_casual(&self) -> MemberCasual {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<MemberCasual>(
                        Trip::VT_MEMBER_CASUAL,
                        Some(MemberCasual::UNKNOWN_MEMBER_CASUAL),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Trip<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "ride_id",
                    Self::VT_RIDE_ID,
                    false,
                )?
                .visit_field::<RideableType>("rideable_type", Self::VT_RIDEABLE_TYPE, false)?
                .visit_field::<i64>("started_at_ms", Self::VT_STARTED_AT_MS, false)?
                .visit_field::<i64>("ended_at_ms", Self::VT_ENDED_AT_MS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "start_station_name",
                    Self::VT_START_STATION_NAME,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "start_station_id",
                    Self::VT_START_STATION_ID,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "end_station_name",
                    Self::VT_END_STATION_NAME,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "end_station_id",
                    Self::VT_END_STATION_ID,
                    false,
                )?
                .visit_field::<f64>("start_lat", Self::VT_START_LAT, false)?
                .visit_field::<f64>("start_lng", Self::VT_START_LNG, false)?
                .visit_field::<f64>("end_lat", Self::VT_END_LAT, false)?
                .visit_field::<f64>("end_lng", Self::VT_END_LNG, false)?
                .visit_field::<MemberCasual>("member_casual", Self::VT_MEMBER_CASUAL, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TripArgs<'a> {
        pub ride_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub rideable_type: RideableType,
        pub started_at_ms: i64,
        pub ended_at_ms: i64,
        pub start_station_name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub start_station_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub end_station_name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub end_station_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub start_lat: f64,
        pub start_lng: f64,
        pub end_lat: f64,
        pub end_lng: f64,
        pub member_casual: MemberCasual,
    }
    impl Default for TripArgs<'_> {
        #[inline]
        fn default() -> Self {
            TripArgs {
                ride_id: None,
                rideable_type: RideableType::UNKNOWN_RIDEABLE_TYPE,
                started_at_ms: 0,
                ended_at_ms: 0,
                start_station_name: None,
                start_station_id: None,
                end_station_name: None,
                end_station_id: None,
                start_lat: 0.0,
                start_lng: 0.0,
                end_lat: 0.0,
                end_lng: 0.0,
                member_casual: MemberCasual::UNKNOWN_MEMBER_CASUAL,
            }
        }
    }

    pub struct TripBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TripBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_ride_id(&mut self, ride_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Trip::VT_RIDE_ID, ride_id);
        }
        #[inline]
        pub fn add_rideable_type(&mut self, rideable_type: RideableType) {
            self.fbb_.push_slot::<RideableType>(
                Trip::VT_RIDEABLE_TYPE,
                rideable_type,
                RideableType::UNKNOWN_RIDEABLE_TYPE,
            );
        }
        #[inline]
        pub fn add_started_at_ms(&mut self, started_at_ms: i64) {
            self.fbb_
                .push_slot::<i64>(Trip::VT_STARTED_AT_MS, started_at_ms, 0);
        }
        #[inline]
        pub fn add_ended_at_ms(&mut self, ended_at_ms: i64) {
            self.fbb_
                .push_slot::<i64>(Trip::VT_ENDED_AT_MS, ended_at_ms, 0);
        }
        #[inline]
        pub fn add_start_station_name(
            &mut self,
            start_station_name: flatbuffers::WIPOffset<&'b str>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Trip::VT_START_STATION_NAME,
                start_station_name,
            );
        }
        #[inline]
        pub fn add_start_station_id(&mut self, start_station_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Trip::VT_START_STATION_ID,
                start_station_id,
            );
        }
        #[inline]
        pub fn add_end_station_name(&mut self, end_station_name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Trip::VT_END_STATION_NAME,
                end_station_name,
            );
        }
        #[inline]
        pub fn add_end_station_id(&mut self, end_station_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Trip::VT_END_STATION_ID,
                end_station_id,
            );
        }
        #[inline]
        pub fn add_start_lat(&mut self, start_lat: f64) {
            self.fbb_
                .push_slot::<f64>(Trip::VT_START_LAT, start_lat, 0.0);
        }
        #[inline]
        pub fn add_start_lng(&mut self, start_lng: f64) {
            self.fbb_
                .push_slot::<f64>(Trip::VT_START_LNG, start_lng, 0.0);
        }
        #[inline]
        pub fn add_end_lat(&mut self, end_lat: f64) {
            self.fbb_.push_slot::<f64>(Trip::VT_END_LAT, end_lat, 0.0);
        }
        #[inline]
        pub fn add_end_lng(&mut self, end_lng: f64) {
            self.fbb_.push_slot::<f64>(Trip::VT_END_LNG, end_lng, 0.0);
        }
        #[inline]
        pub fn add_member_casual(&mut self, member_casual: MemberCasual) {
            self.fbb_.push_slot::<MemberCasual>(
                Trip::VT_MEMBER_CASUAL,
                member_casual,
                MemberCasual::UNKNOWN_MEMBER_CASUAL,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TripBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TripBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Trip<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Trip<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Trip");
            ds.field("ride_id", &self.ride_id());
            ds.field("rideable_type", &self.rideable_type());
            ds.field("started_at_ms", &self.started_at_ms());
            ds.field("ended_at_ms", &self.ended_at_ms());
            ds.field("start_station_name", &self.start_station_name());
            ds.field("start_station_id", &self.start_station_id());
            ds.field("end_station_name", &self.end_station_name());
            ds.field("end_station_id", &self.end_station_id());
            ds.field("start_lat", &self.start_lat());
            ds.field("start_lng", &self.start_lng());
            ds.field("end_lat", &self.end_lat());
            ds.field("end_lng", &self.end_lng());
            ds.field("member_casual", &self.member_casual());
            ds.finish()
        }
    }
    pub enum ServerResponseAllOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ServerResponseAll<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ServerResponseAll<'a> {
        type Inner = ServerResponseAll<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ServerResponseAll<'a> {
        pub const VT_TRIPS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ServerResponseAll { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ServerResponseAllArgs<'args>,
        ) -> flatbuffers::WIPOffset<ServerResponseAll<'bldr>> {
            let mut builder = ServerResponseAllBuilder::new(_fbb);
            if let Some(x) = args.trips {
                builder.add_trips(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn trips(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Trip<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Trip>>,
                >>(ServerResponseAll::VT_TRIPS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ServerResponseAll<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Trip>>,
                >>("trips", Self::VT_TRIPS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ServerResponseAllArgs<'a> {
        pub trips: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Trip<'a>>>>,
        >,
    }
    impl Default for ServerResponseAllArgs<'_> {
        #[inline]
        fn default() -> Self {
            ServerResponseAllArgs { trips: None }
        }
    }

    pub struct ServerResponseAllBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ServerResponseAllBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_trips(
            &mut self,
            trips: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Trip<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ServerResponseAll::VT_TRIPS, trips);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ServerResponseAllBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ServerResponseAllBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ServerResponseAll<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ServerResponseAll<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ServerResponseAll");
            ds.field("trips", &self.trips());
            ds.finish()
        }
    }
} // pub mod Trip
