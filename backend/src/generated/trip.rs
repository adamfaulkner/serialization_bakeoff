//
// This code was generated by a tool.
//
//
//   bebopc version:
//       3.1.3
//
//
//   bebopc source:
//       https://github.com/betwixt-labs/bebop
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//

#![allow(warnings)]

use bebop::FixedSized as _;
use core::convert::TryInto as _;
use std::io::Write as _;

#[repr(u32)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum RideableType {
    Unknown = 0,
    Bicycle = 1,
    Ebicycle = 2,
}

impl ::core::convert::TryFrom<u32> for RideableType {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u32) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(RideableType::Unknown),
            1 => Ok(RideableType::Bicycle),
            2 => Ok(RideableType::Ebicycle),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<RideableType> for u32 {
    fn from(value: RideableType) -> Self {
        match value {
            RideableType::Unknown => 0,
            RideableType::Bicycle => 1,
            RideableType::Ebicycle => 2,
        }
    }
}

impl ::bebop::SubRecord<'_> for RideableType {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u32>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u32>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u32>()
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        u32::from(zelf)._serialize_chained(dest)
    });

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u32::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for RideableType {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u32>();
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum MemberCasual {
    Unknown = 0,
    Member = 1,
    Casual = 2,
}

impl ::core::convert::TryFrom<u32> for MemberCasual {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u32) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(MemberCasual::Unknown),
            1 => Ok(MemberCasual::Member),
            2 => Ok(MemberCasual::Casual),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<MemberCasual> for u32 {
    fn from(value: MemberCasual) -> Self {
        match value {
            MemberCasual::Unknown => 0,
            MemberCasual::Member => 1,
            MemberCasual::Casual => 2,
        }
    }
}

impl ::bebop::SubRecord<'_> for MemberCasual {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u32>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u32>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u32>()
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        u32::from(zelf)._serialize_chained(dest)
    });

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u32::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for MemberCasual {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u32>();
}

#[derive(Clone, Debug, PartialEq)]
pub struct Trip<'raw> {
    pub ride_id: &'raw str,
    pub rideable_type: RideableType,
    pub started_at: ::bebop::Date,
    pub ended_at: ::bebop::Date,
    pub start_station_name: &'raw str,
    pub start_station_id: &'raw str,
    pub end_station_name: &'raw str,
    pub end_station_id: &'raw str,
    pub start_lat: f64,
    pub start_lng: f64,
    pub end_lat: f64,
    pub end_lng: f64,
    pub member_casual: MemberCasual,
}

impl<'raw> ::bebop::SubRecord<'raw> for Trip<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <&'raw str>::MIN_SERIALIZED_SIZE
        + <RideableType>::MIN_SERIALIZED_SIZE
        + <::bebop::Date>::MIN_SERIALIZED_SIZE
        + <::bebop::Date>::MIN_SERIALIZED_SIZE
        + <&'raw str>::MIN_SERIALIZED_SIZE
        + <&'raw str>::MIN_SERIALIZED_SIZE
        + <&'raw str>::MIN_SERIALIZED_SIZE
        + <&'raw str>::MIN_SERIALIZED_SIZE
        + <f64>::MIN_SERIALIZED_SIZE
        + <f64>::MIN_SERIALIZED_SIZE
        + <f64>::MIN_SERIALIZED_SIZE
        + <f64>::MIN_SERIALIZED_SIZE
        + <MemberCasual>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.ride_id.serialized_size()
            + self.rideable_type.serialized_size()
            + self.started_at.serialized_size()
            + self.ended_at.serialized_size()
            + self.start_station_name.serialized_size()
            + self.start_station_id.serialized_size()
            + self.end_station_name.serialized_size()
            + self.end_station_id.serialized_size()
            + self.start_lat.serialized_size()
            + self.start_lng.serialized_size()
            + self.end_lat.serialized_size()
            + self.end_lng.serialized_size()
            + self.member_casual.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.ride_id._serialize_chained(dest)? +
            zelf.rideable_type._serialize_chained(dest)? +
            zelf.started_at._serialize_chained(dest)? +
            zelf.ended_at._serialize_chained(dest)? +
            zelf.start_station_name._serialize_chained(dest)? +
            zelf.start_station_id._serialize_chained(dest)? +
            zelf.end_station_name._serialize_chained(dest)? +
            zelf.end_station_id._serialize_chained(dest)? +
            zelf.start_lat._serialize_chained(dest)? +
            zelf.start_lng._serialize_chained(dest)? +
            zelf.end_lat._serialize_chained(dest)? +
            zelf.end_lng._serialize_chained(dest)? +
            zelf.member_casual._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v4) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v5) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v6) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v7) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v8) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v9) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v10) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v11) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v12) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                ride_id: v0,
                rideable_type: v1,
                started_at: v2,
                ended_at: v3,
                start_station_name: v4,
                start_station_id: v5,
                end_station_name: v6,
                end_station_id: v7,
                start_lat: v8,
                start_lng: v9,
                end_lat: v10,
                end_lng: v11,
                member_casual: v12,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Trip<'raw> {}

#[derive(Clone, Debug, PartialEq, Default)]
pub struct ServerResponseAll<'raw> {
    /// Field 1
    pub trips: ::core::option::Option<::std::vec::Vec<Trip<'raw>>>,
}

impl<'raw> ::bebop::SubRecord<'raw> for ServerResponseAll<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    #[inline]
    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE
            + 1
            + self
                .trips
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        let size = zelf.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;
        if let Some(ref v) = zelf.trips {
            1u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        0u8._serialize_chained(dest)?;
        Ok(size)
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        let len = ::bebop::read_len(&raw[i..])? + ::bebop::LEN_SIZE;
        i += ::bebop::LEN_SIZE;

        #[cfg(not(feature = "unchecked"))]
        if len == 0 {
            return Err(::bebop::DeserializeError::CorruptFrame);
        }

        if raw.len() < len {
            return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
        }

        let mut _trips = None;

        #[cfg(not(feature = "unchecked"))]
        let mut last = 0;

        while i < len {
            let di = raw[i];

            #[cfg(not(feature = "unchecked"))]
            if di != 0 {
                if di < last {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }
                last = di;
            }

            i += 1;
            match di {
                0 => {
                    break;
                }
                1 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _trips.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _trips = Some(value)
                }
                _ => {
                    i = len;
                    break;
                }
            }
        }

        if i != len {
            debug_assert!(i > len);
            return Err(::bebop::DeserializeError::CorruptFrame);
        }

        Ok((i, Self { trips: _trips }))
    }
}

impl<'raw> ::bebop::Record<'raw> for ServerResponseAll<'raw> {}

#[cfg(feature = "bebop-owned-all")]
pub mod owned {
    #![allow(warnings)]

    use bebop::FixedSized as _;
    use core::convert::TryInto as _;
    use std::io::Write as _;

    pub use super::RideableType;

    pub use super::MemberCasual;

    #[derive(Clone, Debug, PartialEq)]
    pub struct Trip {
        pub ride_id: String,
        pub rideable_type: RideableType,
        pub started_at: ::bebop::Date,
        pub ended_at: ::bebop::Date,
        pub start_station_name: String,
        pub start_station_id: String,
        pub end_station_name: String,
        pub end_station_id: String,
        pub start_lat: f64,
        pub start_lng: f64,
        pub end_lat: f64,
        pub end_lng: f64,
        pub member_casual: MemberCasual,
    }

    impl<'raw> ::core::convert::From<super::Trip<'raw>> for Trip {
        fn from(value: super::Trip) -> Self {
            Self {
                ride_id: value.ride_id.into(),
                rideable_type: value.rideable_type,
                started_at: value.started_at,
                ended_at: value.ended_at,
                start_station_name: value.start_station_name.into(),
                start_station_id: value.start_station_id.into(),
                end_station_name: value.end_station_name.into(),
                end_station_id: value.end_station_id.into(),
                start_lat: value.start_lat,
                start_lng: value.start_lng,
                end_lat: value.end_lat,
                end_lng: value.end_lng,
                member_casual: value.member_casual,
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Trip {
        const MIN_SERIALIZED_SIZE: usize = <String>::MIN_SERIALIZED_SIZE
            + <RideableType>::MIN_SERIALIZED_SIZE
            + <::bebop::Date>::MIN_SERIALIZED_SIZE
            + <::bebop::Date>::MIN_SERIALIZED_SIZE
            + <String>::MIN_SERIALIZED_SIZE
            + <String>::MIN_SERIALIZED_SIZE
            + <String>::MIN_SERIALIZED_SIZE
            + <String>::MIN_SERIALIZED_SIZE
            + <f64>::MIN_SERIALIZED_SIZE
            + <f64>::MIN_SERIALIZED_SIZE
            + <f64>::MIN_SERIALIZED_SIZE
            + <f64>::MIN_SERIALIZED_SIZE
            + <MemberCasual>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.ride_id.serialized_size()
                + self.rideable_type.serialized_size()
                + self.started_at.serialized_size()
                + self.ended_at.serialized_size()
                + self.start_station_name.serialized_size()
                + self.start_station_id.serialized_size()
                + self.end_station_name.serialized_size()
                + self.end_station_id.serialized_size()
                + self.start_lat.serialized_size()
                + self.start_lng.serialized_size()
                + self.end_lat.serialized_size()
                + self.end_lng.serialized_size()
                + self.member_casual.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.ride_id._serialize_chained(dest)? +
                zelf.rideable_type._serialize_chained(dest)? +
                zelf.started_at._serialize_chained(dest)? +
                zelf.ended_at._serialize_chained(dest)? +
                zelf.start_station_name._serialize_chained(dest)? +
                zelf.start_station_id._serialize_chained(dest)? +
                zelf.end_station_name._serialize_chained(dest)? +
                zelf.end_station_id._serialize_chained(dest)? +
                zelf.start_lat._serialize_chained(dest)? +
                zelf.start_lng._serialize_chained(dest)? +
                zelf.end_lat._serialize_chained(dest)? +
                zelf.end_lng._serialize_chained(dest)? +
                zelf.member_casual._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v4) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v5) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v6) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v7) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v8) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v9) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v10) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v11) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v12) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    ride_id: v0,
                    rideable_type: v1,
                    started_at: v2,
                    ended_at: v3,
                    start_station_name: v4,
                    start_station_id: v5,
                    end_station_name: v6,
                    end_station_id: v7,
                    start_lat: v8,
                    start_lng: v9,
                    end_lat: v10,
                    end_lng: v11,
                    member_casual: v12,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Trip {}

    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct ServerResponseAll {
        /// Field 1
        pub trips: ::core::option::Option<::std::vec::Vec<Trip>>,
    }

    impl<'raw> ::core::convert::From<super::ServerResponseAll<'raw>> for ServerResponseAll {
        fn from(value: super::ServerResponseAll) -> Self {
            Self {
                trips: value
                    .trips
                    .map(|value| value.into_iter().map(|value| value.into()).collect()),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for ServerResponseAll {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        #[inline]
        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE
                + 1
                + self
                    .trips
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            let size = zelf.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;
            if let Some(ref v) = zelf.trips {
                1u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            0u8._serialize_chained(dest)?;
            Ok(size)
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            let len = ::bebop::read_len(&raw[i..])? + ::bebop::LEN_SIZE;
            i += ::bebop::LEN_SIZE;

            #[cfg(not(feature = "unchecked"))]
            if len == 0 {
                return Err(::bebop::DeserializeError::CorruptFrame);
            }

            if raw.len() < len {
                return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
            }

            let mut _trips = None;

            #[cfg(not(feature = "unchecked"))]
            let mut last = 0;

            while i < len {
                let di = raw[i];

                #[cfg(not(feature = "unchecked"))]
                if di != 0 {
                    if di < last {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }
                    last = di;
                }

                i += 1;
                match di {
                    0 => {
                        break;
                    }
                    1 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _trips.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _trips = Some(value)
                    }
                    _ => {
                        i = len;
                        break;
                    }
                }
            }

            if i != len {
                debug_assert!(i > len);
                return Err(::bebop::DeserializeError::CorruptFrame);
            }

            Ok((i, Self { trips: _trips }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for ServerResponseAll {}
}
